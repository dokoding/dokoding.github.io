[ { "title": "Tailwind의 마법사, Preflight가 해주는 일", "url": "/posts/Tailwind%EC%9D%98-%EB%A7%88%EB%B2%95%EC%82%AC,-Preflight%EA%B0%80-%ED%95%B4%EC%A3%BC%EB%8A%94-%EC%9D%BC/", "categories": "CSS", "tags": "Preflight", "date": "2023-09-05 20:00:00 +0900", "snippet": "안녕하세요, 오늘은 웹 디자인과 스타일링의 마법사라고 불릴 만한 Tailwind의 Preflight에 대해 얘기해 볼 거예요. 왜 마법사라고 부르냐구요? 이유는 바로 이어서 알려 드릴게요. 😎브라우저, 너의 스타일은 내가 지워주마! 🧹브라우저는 각각 고유한 스타일을 가지고 있어서 같은 CSS를 주어도 살짝씩 다르게 출력됩니다. 하지만 이때 Preflight가 등장하는 순간! Preflight는 브라우저가 마음대로 입힌 스타일을 다 지워버립니다. 이렇게 되면 다른 브라우저 일지라도 일관된 UI를 만들 수 있죠.뭐가 어떻게 변하는데? 🤔 모든 HTML 요소의 margin과 padding을 없앱니다. &lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt; 등 헤딩에 적용된 스타일을 일괄 삭제합니다. 리스트(&lt;ul&gt;, &lt;ol&gt;)의 스타일도 지웁니다. 멀티미디어 요소(&lt;img&gt;, &lt;svg&gt;)의 display 속성을 block으로 설정합니다.graph TD; A[브라우저 스타일] --&gt; B[Preflight]; B --&gt; C[일관된 UI];위 다이어그램에서 볼 수 있듯이, Preflight는 브라우저 스타일을 거쳐 일관된 UI를 만들어줍니다. 브라우저마다 조금씩 다른 스타일이 적용되는 것을 막아주는거죠!Tailwind Preflight 설정 방법 🛠Preflight는 기본적으로 Tailwind에서 활성화되어 있습니다. 만약 비활성화하고 싶다면, 이렇게 하면 됩니다. Tailwind 설정 파일을 열어주세요. corePlugins 섹션에서 preflight를 false로 설정하세요.module.exports = { corePlugins: { preflight: false, },};마무리 🎉이제 Preflight에 대해 알게 됐으니, Tailwind를 쓸 때는 더 이상 브라우저 스타일로 고생하지 않을 거예요. Tailwind와 Preflight의 조합은 진짜 환상적이니까요! 🚀✨" }, { "title": "object-fit으로 이미지 안짤리게 사용하기", "url": "/posts/object-fit%EC%9C%BC%EB%A1%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%95%88%EC%A7%A4%EB%A6%AC%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/", "categories": "CSS", "tags": "object-fit", "date": "2023-09-04 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 이미지를 웹에 어떻게 안짤리고 잘 보이게 할 수 있을까요? 오늘은 CSS의 ‘object-fit’ 속성을 통해 그 놀라운 비결을 알려드립니다! 🌈💡 object-fit의 기본 설정: fill 🎈이미지를 웹에 첨부하려고 하면 기본 설정으로 fill이 자동으로 적용됩니다. 하지만 fill은 이미지의 가로, 세로 비율을 무시해버려요. 그래서 이미지가 찌그러질 가능성이 크기 때문에 fill은 사실상 사용을 피하는 편이에요.&lt;!-- fill 예제 --&gt;&lt;img src=\"https://dummyimage.com/200x200.png\" style=\"object-fit: fill;\" /&gt;🌟 별도로 설정하지 않으면 뭐가 되나요? 🌠방금 말했듯이, 별도로 object-fit 설정을 안 하면 웹 브라우저는 이미지의 원래 가로 세로 비율을 유지하려고 노력합니다. 헌데 이렇게 하면 원치 않게 이미지가 너무 커져서 페이지를 깨뜨리거나 스크롤바를 생성할 수 있어요.😎 object-fit: cover, 그 놀라운 효과! 🚀그때 사용되는게 바로 object-fit: cover; 입니다. 이 설정은 정말 놀라워요! 원본 이미지의 가로 세로 비율을 유지하면서도, 지정한 너비와 높이에 딱 맞게 이미지를 보여줍니다.&lt;!-- cover 예제 --&gt;&lt;img src=\"https://dummyimage.com/300x100.png\" style=\"object-fit: cover;\" /&gt;이렇게 하면 이미지의 일부가 잘릴 수 있어요. 그러나 잘린 부분을 감수하고 이미지의 비율을 유지하려는 당신! 이 설정은 당신을 위한 최고의 선택일 거에요.graph TD; A[object-fit] --&gt; B(fill) A --&gt; C(cover) B --&gt; D1(왜곡 발생) C --&gt; D2(비율 유지) D1 --&gt; E1(비추천 😫) D2 --&gt; E2(추천! 😍)graph TD; A[object-fit 설정법] --&gt;|방법1| B[fill로 설정] A --&gt;|방법2| C[cover로 설정] B --&gt; D[비추: 이미지 찌그러짐] C --&gt; E[추천: 이미지 비율 유지]🤓 object-fit의 위대함을 느껴보세요! 🎉오늘 알려드린 object-fit을 사용해 이미지의 왜곡 문제를 해결하고, 웹 페이지를 더욱 아름답게 만들어보세요. 저는 다음글에서 또 찾아 뵙겠습니다, 감사합니다." }, { "title": "CSS 화면 높이 조절 이거 알면 끝나요(%, vh)", "url": "/posts/CSS-%ED%99%94%EB%A9%B4-%EB%86%92%EC%9D%B4-%EC%A1%B0%EC%A0%88-%EC%9D%B4%EA%B1%B0-%EC%95%8C%EB%A9%B4-%EB%81%9D%EB%82%98%EC%9A%94(-,-vh)/", "categories": "CSS", "tags": "CSS화면높이", "date": "2023-09-03 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 이번 글에서는 CSS로 화면 높이를 잡는 기술에 대해 핵심만 짧게 알아보겠습니다. 이 글을 끝까지 읽으시면 더이상 %와 vh중에 뭘 써야할지에 대한 고민이 사라지실거에요! 🚀🔍 주의해야 할 흔한 실수들CSS를 다룰 때, 특히 초보자분들이 자주 하는 실수 중 하나는 height 속성을 100%로 설정하고, 그것만으로 해결될 것이라고 생각하는 거에요..screen-height { height: 100%;}하지만 이렇게만 하면 대부분 변화가 없죠. 왜냐면, %는 부모 요소를 기준으로 하고, 부모 요소의 height는 기본적으로 auto로 설정되어 있기 때문이에요.👍 html과 body 요소의 높이 조절이럴 때, html과 body 요소의 높이를 100%로 설정하면 문제가 해결되곤 해요.html, body { height: 100%;}이렇게 하면 html 요소와 body 요소가 브라우저의 화면 높이를 차지하게 되고, 이를 기준으로 자식 요소들의 높이도 설정할 수 있는 원리에요. 이처럼 %는 부모요소의 높이에 영향을 받는것이 특징이에요!🌟 뷰포트 높이 단위 활용하기반면 뷰포트 단위, 즉 vh를 사용하면 부모 요소에 상관없이 사용자의 화면 높이에 맞게 설정할 수 있어요..screen-height { height: 100vh;}📌 모바일에서 주의할 점모바일에서는 주소 표시줄이 유동적으로 변하기 때문에 vh 단위를 사용할 때 조심해야 해요. 특히 iOS의 사파리나 안드로이드의 크롬에서는 이 문제가 자주 발생하죠.📊 다이어그램을 활용한 이해 돕기graph TD; A[html, body 높이 설정] --&gt;|방법1| B[100%로 설정] A --&gt;|방법2| C[vh로 설정] B --&gt; D[다른 요소 높이 설정 가능] C --&gt; E[다른 요소 높이 자동 조절]이 다이어그램을 보면, html과 body의 높이 설정에 따라 다른 요소들의 높이 설정 방법이 달라지는 것을 알 수 있어요. 😉🎉 마무리하며그래서 여러분, CSS로 화면 높이를 조절할 때는 이렇게 여러 가지 방법과 주의점이 있답니다. 각 상황에 맞는 최적의 방법을 선택하면 더 이상 화면 높이 때문에 고민하지 않아도 될 거에요! 🎈이제 웹 레이아웃을 만드는 마법사가 되어보시죠! 🧙‍♂️🌟안녕하세요, 여러분! 이번 글에서는 CSS로 화면 높이를 잡는 기술에 대해 깊이 있고 자세히 알아보겠습니다. 딱 그거죠, 웹 페이지의 레이아웃을 조절할 때 종종 겪는 고민들을 한방에 해결해보려고 해요! 🚀🔍 주의해야 할 흔한 실수들CSS를 다룰 때, 특히 초보자분들이 자주 하는 실수 중 하나는 height 속성을 100%로 설정하고, 그것만으로 해결될 것이라고 생각하는 거에요..screen-height { height: 100%;}하지만 이렇게만 하면 대부분 변화가 없죠. 왜냐면, %는 부모 요소를 기준으로 하고, 부모 요소의 height는 기본적으로 auto로 설정되어 있기 때문이에요.👍 html과 body 요소의 높이 조절html과 body 요소의 높이를 100%로 설정하면 문제가 해결되곤 해요.html, body { height: 100%;}이렇게 하면 html 요소와 body 요소가 브라우저의 화면 높이를 차지하게 되고, 이를 기준으로 다른 요소들의 높이도 설정할 수 있어요.🌟 뷰포트 높이 단위 활용하기뷰포트 단위, 즉 vh를 사용하면 부모 요소에 상관없이 화면 높이에 맞게 설정할 수 있어요..screen-height { height: 100vh;}📌 모바일에서 주의할 점모바일에서는 주소 표시줄이 유동적으로 변하기 때문에 vh 단위를 사용할 때 조심해야 해요. 특히 iOS의 사파리나 안드로이드의 크롬에서는 이 문제가 자주 발생하죠.📊 다이어그램을 활용한 이해 돕기graph TD; A[height 높이 설정법] --&gt;|방법1| B[%로 설정] A --&gt;|방법2| C[vh로 설정] B --&gt; D[부모 요소의 높이에 영향을 받음] C --&gt; E[부모 요소의 높이가 아닌 화면 높이에 영향을 받음]이 다이어그램을 보면, html과 body의 높이 설정에 따라 다른 요소들의 높이 설정 방법이 달라지는 것을 알 수 있어요. 😉🎉 마무리하며오늘은, CSS로 화면 높이를 조절하는 2가지 방법을 알아봤어요! 각 상황에 맞는 최적의 방법을 선택하면 더 이상 화면 높이 때문에 고민하지 않아도 될 거에요! 🎈 이제 웹 레이아웃을 만드는 마법사가 되어볼까요? 🧙‍♂️🌟" }, { "title": "CSS 포커스(focus) 사용하지 마세요", "url": "/posts/CSS-%ED%8F%AC%EC%BB%A4%EC%8A%A4(focus)-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%88%EC%84%B8%EC%9A%94/", "categories": "CSS", "tags": "CSS포커스", "date": "2023-09-02 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 🎉 오늘은 CSS에서 사용되는 :focus, :focus-visible, :focus-within 가상 클래스를 제대로 알아보고, 그 차이점과 사용법을 풀어내볼 거에요.🌈 HTML 요소와 포커스의 비밀먼저, HTML 요소(element)가 포커스를 받는다는 의미를 이해하려면, 어떤 요소만이 포커스의 주인공이 될 수 있는지 알아봐야 해요. 대표적으로 &lt;a&gt;, &lt;input&gt;, &lt;select&gt;, &lt;button&gt; 등이 있는데요, 이러한 요소들을 대화형 요소라고 불러요. 주로 사용자의 입력을 받는 용도로 사용돼요.🎯 CSS :focus 가상 클래스의 정체:focus는 마우스든 키보드든 뭐든지 간에 HTML 요소에 포커스가 가면, 그 요소를 화려하게 꾸밀 수 있어요. 예를 들면,:focus { /* 포커스가 가면 이렇게 예쁘게! */ outline: 2px solid gold;}이렇게 하면 포커스 상태에서는 금빛 둘레선이 생기는 거죠.😵 그런데, 문제가 있어요!:focus로 스타일을 지정하면, 마우스로 클릭한 요소가 포커스를 받게 되는데, 문제는 다른 곳을 클릭해도 그 스타일이 그대로 남아있어요. 마치 뭐…초콜릿 얼룩이 옷에 묻은 것처럼요! 🍫🕵️ :focus-visible로 해결하자!:focus-visible 가상 클래스는 키보드 포커스에만 스타일을 적용하는 똑똑한 녀석이에요.:focus-visible { outline: 2px solid green;}이제 키보드로 포커스를 준 요소만 초록색으로 둘러싸일 거에요! 🌿🌠 :focus-within로 요소 전체 변경이 친구는 어떤 요소 안에 포커스가 있는 경우, 그 요소까지 포함해서 스타일을 줄 수 있어요. 예를 들어,:focus-within { background-color: lightblue;}이 코드는 어떤 요소 안에 포커스가 가면, 그 요소 전체가 하늘색으로 변해요! 🦋📊 다이어그램으로 이해하기graph TD; A[전체 HTML 요소] --&gt; B[대화형 요소만 포커스 가능] B --&gt; C[:focus] B --&gt; D[:focus-visible] B --&gt; E[:focus-within] C --&gt; F[스타일 흔적 남음] D --&gt; G[스타일 흔적 안남음] E --&gt; H[요소 전체에 스타일 줄 수 있음]이 다이어그램을 보면, 전체 HTML 요소중에 대화형 요소만 포커스를 받을 수 있고, 그 때 다양한 가상 클래스를 사용할 수 있다는 것을 쉽게 이해할 수 있을 거에요. 📚😆 마무리오늘은 CSS의 :focus, :focus-visible, :focus-within 가상 클래스에 대해 알아봤어요. 이 친구들을 잘 활용하면 웹 페이지를 더 사용자 친화적으로 만들 수 있답니다. 앞으로 이 친구들과 잘 지내보세요! 🎉👏" }, { "title": "완벽한 React 프로젝트 구성을 위한 Create React App", "url": "/posts/%EC%99%84%EB%B2%BD%ED%95%9C-React-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-Create-React-App/", "categories": "React", "tags": "CreateReactApp", "date": "2023-08-26 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 🎉 오늘은 Create React App에 대해 살펴볼 예정입니다. React 프로젝트를 만들려면 알아야 할 것이 산더미처럼 많죠. 웹팩, 바벨, 뭐 어쩌고 저쩌고. 😱 다른 글에서 볼 수 있는 복잡한 정보는 건너뛰고, 이 글에서는 정확히 핵심만 파보겠습니다! ✨Create React App이 뭐에요? 🤔React를 배우고 싶지만 설정 때문에 머리 아프다면, Create React App 하나로 그런 복잡한 설정을 다 해준답니다. 😲 명령어 하나로 바로 시작하세요!프로젝트 만드는 법 🛠첫 번째 단계는 정말 간단합니다. 아래와 같이 터미널에 명령어를 입력하세요.$ npx create-react-app 앱이름 --use-npm’–use-npm’ 옵션은 npm을 패키지 매니저로 사용하겠다는 의미입니다. 만약 Yarn을 좋아하신다면, 그냥 옵션을 빼면 돼요!파일 구조 살펴보기 📂프로젝트가 성공적으로 생성되면, 이런 구조를 볼 수 있을 거에요:$ cd my-amazing-app$ tree -L 2 -I node_modules.├── README.md├── package-lock.json├── package.json├── public│ ├── favicon.ico│ ├── index.html│ ├── ...└── src ├── App.css ├── App.js ├── ...애플리케이션 실행 🏃‍♀️코드를 작성한 뒤 결과를 확인하고 싶다면, 아래와 같이 하세요:$ npm start이제 브라우저에서 http://localhost:3000을 열면, 놀라운 React 앱을 볼 수 있어요! 🎉테스트 어떻게 하나요? 🧪Jest와 Testing Library가 이미 설정되어 있어요. 아래 명령어로 테스트를 실행하세요:$ npm test‘watch’ 모드를 사용하면 변경된 테스트만 실행할 수 있어요. 전체 테스트를 실행하려면, ‘a’ 키를 누르면 돼요!머메이드 다이어그램을 활용한 이해 돕기 📊graph TD; A[Create React App] --&gt; B[프로젝트 생성] B --&gt; C[애플리케이션 실행] B --&gt; D[테스트 실행]마무리 🎬이로써 Create React App에 대한 사용법이 끝났습니다! 이제 React 세계의 정복자가 될 준비가 되었죠? 💪" }, { "title": "메타 프레임워크 웹 개발의 비밀 병기", "url": "/posts/%EB%A9%94%ED%83%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%9B%B9-%EA%B0%9C%EB%B0%9C%EC%9D%98-%EB%B9%84%EB%B0%80-%EB%B3%91%EA%B8%B0/", "categories": "React", "tags": "메타프레임워크", "date": "2023-08-25 20:00:00 +0900", "snippet": "안녕하세요! 👋 여러분, 오늘은 메타 프레임워크에 대해 이야기하려고 합니다. 어떤 마법의 힘을 가지고 있는 건지 궁금하신가요? 잠깐만요, 토끼 귀를 세워주세요! 🐰메타 프레임워크의 비밀 슈퍼파워 🦸‍♀️메타 프레임워크가 대체 뭐에요? 일반 프레임워크가 슈퍼맨이라면, 메타 프레임워크는 아이언맨입니다. 왜냐하면 아이언맨은 기술을 더해서 더 강해지니까요! 🦾 메타 프레임워크는 다양한 라이브러리와 일반 프레임워크들을 조합해서 완벽한 하나를 만들어 냅니다. 🤖메타 프레임워크 vs 일반 프레임워크 👊일반 프레임워크는 한 가지 언어나 기술에 특화되어 있습니다. Java의 세계에서는 Spring이 대표적이죠. JavaScript 세계는? 여기서는 일반 프레임워크가 없어요. 대신 다양한 라이브러리와 프레임워크를 섞어서 사용합니다. 이런 것들을 다 관리하는 슈퍼히어로가 바로 메타 프레임워크입니다! 🦸‍♂️메타 프레임워크의 필요성은? 🤷‍♀️자바스크립트에서는 라이브러리가 너무 많아요. 패키지 매니저만 해도 npm, Yarn, pnpm 등이 있습니다. 하나하나 선택하다 보면 머리가 아파 올 것 같죠? 😫 메타 프레임워크가 여러분을 구해 줍니다! 어떻게? 모든 것을 선택해 주면서도 최적의 성능을 뽑아 줍니다. 😌graph TD; A[자바스크립트 라이브러리] --&gt; B[메타 프레임워크]; C[일반 프레임워크] --&gt; B; D[프로젝트 설정] --&gt; B; B --&gt; E[완벽한 웹 애플리케이션];메타 프레임워크의 추천 리스트 📜이 세상에는 다양한 메타 프레임워크가 있습니다. 그 중 몇 가지는 Next.js, Nuxt.js, Sapper 등이 있죠. 이들은 자바스크립트의 주류 프레임워크에 확장을 제공하면서도 고유한 장점을 갖고 있습니다. 😎오늘의 이야기를 마무리하며, 메타 프레임워크가 웹 개발에 있어 강력한 도구라는 것을 깨달았으면 좋겠습니다. 다음에 또 뵙겠습니다. 안녕! 👋🎉" }, { "title": "리액트 훅 테스팅 마스터 되기", "url": "/posts/%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%9B%85-%ED%85%8C%EC%8A%A4%ED%8C%85-%EB%A7%88%EC%8A%A4%ED%84%B0-%EB%90%98%EA%B8%B0/", "categories": "React", "tags": "리액트훅테스팅", "date": "2023-08-24 20:00:00 +0900", "snippet": "안녕하세요! 오늘은 여러분과 함께 리액트 훅(React Hook)을 어떻게 테스팅할 수 있는지 배워보는 시간을 갖겠습니다. 먼저 사전 안내! 이 글을 끝까지 읽으면 리액트 훅 테스팅을 마스터할 수 있는 비법이 공개됩니다. 🎉목차 📚 리액트 훅이란? 테스팅 라이브러리 선택하기 코드 예시로 이해하기 꿀팁과 요약리액트 훅이란? 🤔리액트 훅은 리액트의 새로운 기능입니다. 함수형 컴포넌트에서도 상태를 가질 수 있게 도와주죠. useState, useEffect 같은 기본 훅도 있고, 우리가 직접 만든 커스텀 훅도 있습니다.import { useState, useEffect } from 'react';function MyComponent() { const [count, setCount] = useState(0); useEffect(() =&gt; { // Something amazing happens here! }, []); return &lt;div&gt;{count}&lt;/div&gt;;}테스팅 라이브러리 선택하기 🎯훅을 테스트할 때는 크게 두 가지 방법이 있습니다. 하나는 React Testing Library, 다른 하나는 React Hooks Testing Library입니다. 여기서는 React Hooks Testing Library를 사용해 보겠습니다.$ npm i -D @testing-library/react-hooks코드 예시로 이해하기 📝// useToggle.jsimport { useState, useCallback } from 'react';const useToggle = (initialState = false) =&gt; { const [state, setState] = useState(initialState); const toggle = useCallback(() =&gt; setState(!state), []); return [state, toggle];};export default useToggle;이런 코드를 테스트하려면 어떻게 해야 할까요? 아래와 같이 해볼 수 있습니다!import { renderHook, act } from '@testing-library/react-hooks';import useToggle from './useToggle';test('초기값이 false일 때 토글을 누르면 true가 되어야 한다!', () =&gt; { const { result } = renderHook(() =&gt; useToggle()); expect(result.current[0]).toBe(false); act(() =&gt; { result.current[1](); }); expect(result.current[0]).toBe(true);});꿀팁과 요약 🍯 훅 테스팅은 React Hooks Testing Library를 사용하면 쉽습니다. renderHook과 act를 사용해 실제 컴포넌트 동작을 시뮬레이션할 수 있어요. result.current로 현재 상태와 함수에 접근할 수 있습니다.요렇게 하면 리액트 훅 테스팅은 어렵지 않죠! 이제 여러분도 리액트 훅 테스팅 마스터입니다! 🥳😎👏 다음 번에는 더 깊고 흥미로운 주제로 찾아뵙겠습니다. 그럼 안녕! 👋" }, { "title": "리액트 페이지네이션 단숨에 구현하기", "url": "/posts/%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98-%EB%8B%A8%EC%88%A8%EC%97%90-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/", "categories": "React", "tags": "페이지네이션", "date": "2023-08-23 20:00:00 +0900", "snippet": "안녕하세요! 오늘은 웹사이트에서 자주 보는 페이지네이션을 소개할 거에요! 게시물이 무지~ 많다면, 한 번에 다 보여주기가 힘들죠? 이럴 때 사용하는게 바로 페이지네이션입니다.파트1: 첫 번째 장, 모든 게시물을 다 보여주려고 해볼까?JSON Placeholder라는 곳에서 게시물 데이터를 가져와서 먼저 모든 게시물을 화면에 뿌려보려고 했어요. 근데 이렇게 하니까 사람들이 스크롤에 지쳐서 쓰러지는 사태가 발생! 😲// 모든 게시물을 불러와서 보여줍니다.function Posts() { const [posts, setPosts] = useState([]); useEffect(() =&gt; { fetch(\"https://jsonplaceholder.typicode.com/posts\") .then((res) =&gt; res.json()) .then((data) =&gt; setPosts(data)); }, []); return ( &lt;Layout&gt; &lt;header&gt; &lt;h1&gt;게시물 목록&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; {posts.map(({ id, title, body }) =&gt; ( &lt;article key={id}&gt; &lt;h3&gt;{id}. {title}&lt;/h3&gt; &lt;p&gt;{body}&lt;/p&gt; &lt;/article&gt; ))} &lt;/main&gt; &lt;/Layout&gt; );}파트2: 페이지네이션 알고리즘 배우기! 🎓스크롤 문제 해결을 위해 페이지네이션 알고리즘이 필요해졌어요. 첫 번째로 알아야 할 것은 ‘전체 게시물 수 / 페이지 당 게시물 수 = 총 페이지 수’ 입니다! 예를 들어, 게시물이 37개 있고, 페이지 당 게시물이 10개면, 총 페이지는 4개가 되는 거죠!그 다음, 현재 페이지에서 보여줄 게시물의 범위를 계산해야 해요. 첫 게시물의 위치 = (현재 페이지 - 1) * 페이지 당 게시물 수 로 계산할 수 있어요!파트3: 마법의 주문을 외워보자, 페이지네이션 구현! 🪄이제 알고리즘을 배웠으니, 페이지네이션을 구현해볼까요? 현재 페이지에 맞는 게시물만 보여주도록 코드를 수정했어요!function Posts() { const [posts, setPosts] = useState([]); const [limit, setLimit] = useState(10); const [page, setPage] = useState(1); const offset = (page - 1) * limit; useEffect(() =&gt; { fetch(\"https://jsonplaceholder.typicode.com/posts\") .then((res) =&gt; res.json()) .then((data) =&gt; setPosts(data)); }, []); return ( &lt;Layout&gt; &lt;header&gt; &lt;h1&gt;게시물 목록&lt;/h1&gt; &lt;/header&gt; {posts.slice(offset, offset + limit).map(({ id, title, body }) =&gt; ( &lt;article key={id}&gt; &lt;h3&gt;{id}. {title}&lt;/h3&gt; &lt;p&gt;{body}&lt;/p&gt; &lt;/article&gt; ))} &lt;/Layout&gt; );}다이어그램 📊graph TD; A[게시물 목록 가져오기] --&gt; B[게시물 수 계산] B --&gt; C[총 페이지 수 계산] C --&gt; D[현재 페이지 설정] D --&gt; E[첫 게시물 위치 계산] E --&gt; F[화면에 게시물 출력]마무리: 페이지네이션, 이렇게 간단하죠!이제 페이지네이션의 마법을 마스터했어요! 🧙‍♀️ 이제 사람들은 스크롤로 지치지 않고 행복하게 웹사이트를 둘러볼 수 있을 거에요. 다음에 또 재미있는 이야기로 찾아뵐게요! 🌈" }, { "title": "리액트 사이드 네비게이션 쉽게 만들기", "url": "/posts/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%84%A4%EB%B9%84%EA%B2%8C%EC%9D%B4%EC%85%98-%EC%89%BD%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "React", "tags": "사이드네비게이션", "date": "2023-08-22 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 여러분을 위한 특별한 레시피를 가져왔어요. 바로 “React와 Styled Components로 사이드 네비게이션 UI를 만드는 방법”이죠! 🎉컴파운트 컴포넌트: 가족보다 더 가까운 관계 👨‍👩‍👦어려운 단어부터 나왔네요! 컴파운트 컴포넌트는 그냥 같이 쓰이는 친구들을 묶어주는 것입니다. 예를 들어, &lt;option&gt;은 &lt;select&gt; 안에서만 쓰이고, &lt;li&gt;는 &lt;ul&gt;이나 &lt;ol&gt; 안에서만 쓰이죠. 이런 친구들을 React에서는 컴파운트 컴포넌트로 묶어줍니다. 어떻게 묶는지 지금부터 차근차근 알아볼게요!네비게이션 UI의 신세계: JSX가 나선다 🚀HTML로 네비게이션을 만들면 태그가 좀 많이 나와요. &lt;nav&gt;, &lt;ul&gt;, &lt;li&gt; 이런 것들이죠. 하지만 JSX를 사용하면 &lt;Nav&gt; 하나로 끝낼 수 있어요!// 일반적인 HTML 네비게이션&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;// JSX로 만든 네비게이션&lt;Nav&gt; &lt;Nav.List&gt; &lt;Nav.Item&gt;&lt;Nav.Link to=\"/\"&gt;Home&lt;/Nav.Link&gt;&lt;/Nav.Item&gt; &lt;/Nav.List&gt;&lt;/Nav&gt;훨씬 간단하고 깔끔하지 않아요? 🎉다이어그램으로 이해하기 📊graph TD; A[Nav] --&gt; B[Nav.List]; B --&gt; C[Nav.Item]; C --&gt; D[Nav.Link]; B -.-&gt; E[Nav.Separator];이 다이어그램을 보면 Nav &gt; Nav.List &gt; Nav.Item &gt; Nav.Link 이렇게 구조가 되어 있음을 쉽게 알 수 있어요. 아, 그리고 Nav.Separator는 Nav.List와 병렬로 들어가는 친구입니다!Styled Components로 스타일링 척척 🎨스타일링은 Styled Components를 사용하면 굉장히 쉬워져요. 아래 코드는 Nav 컴포넌트의 스타일을 정의한 예시입니다.import styled from \"styled-components\";const Navigation = styled.nav` min-width: 200px; padding-right: 20px;`;function Nav({ children }) { return &lt;Navigation&gt;{children}&lt;/Navigation&gt;;}이렇게 하면 모든 Nav 컴포넌트는 이 스타일을 따르게 되어요! 간단하죠? 😉아주 쉽고 재밌게 리액트 사이드 네비게이션 UI를 만드는 방법을 알아봤어요. 이제 여러분도 이 기술을 활용해 웹사이트를 더 멋지게 만들 수 있을 거예요! 👏👏👏더 알고 싶은 것이나 궁금한 것이 있다면 댓글로 남겨주세요! 다음에도 더 멋진 코드와 함께 돌아올게요! 🌟" }, { "title": "SPA, SSG, SSR의 차이점", "url": "/posts/SPA,-SSG,-SSR%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/", "categories": "React", "tags": "서버사이드랜더링", "date": "2023-08-20 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 SPA, SSG, SSR에 대해서 이야기하려고 해요. 뭔지 헷갈리시나요? 괜찮아요. 이 글을 다 읽고 나면 이 세 친구들을 제대로 알게 될 거에요. 😄SPA가 뭔데?🌈SPA(Single Page Application)는 하나의 페이지에서 모든 것이 이루어지는 웹 애플리케이션입니다. 여러분이 클릭하거나 스크롤을 하면, 새로고침 없이 그때그때 페이지가 바뀌어요.이렇게 SPA는 한 번만 서버에게 정보를 요청하고, 그 다음부터는 브라우저가 알아서 처리해줍니다. 빠르고 부드러운 사용자 경험, 이게 바로 SPA의 매력이에요!다만 서버에 정보를 요청하기 전에 검색엔진이 사이트를 긁어가는 경우가 많아 SEO적으로 불리하다는 단점이 있어요.SSG는 뭘까? 💥이제 SSG(Static Site Generator)에 대해서 알아볼 거에요. SSG는 미리 만들어진 정적인 페이지를 제공합니다. 이게 왜 중요하냐고요? 바로 SEO 때문입니다! 정적인 페이지가 빠르게 로딩되니까 검색 엔진이 페이지를 더 잘 이해할 수 있어요.😆SSR은 뭐지? 🤔마지막으로 SSR(Server-Side Rendering)에 대해서 이야기할 거에요. SSR은 서버에서 페이지를 미리 만들어서 보내준다는 것입니다. 이러면 SPA의 문제점 중 하나인 SEO 문제를 해결할 수 있어요.SSR은 페이지를 빠르게 만들어주고, 검색 엔진도 이해하기 쉬워서 엄청나게 유용합니다!정리하자면? 🌠 SPA는 한 번 로딩하고 나면 빠르고 멋진 웹을 만들 수 있어요. 근데 SEO에는 안좋아요. SSG는 SEO가 뛰어나고, 빠르게 로딩되요. SSR은 SPA의 SEO 문제를 해결하고, 빠른 로딩을 지원해요.그래서 이 세 친구들, 적재적소에 잘 활용하면 웹 개발은 더 이상 어렵지 않아요! 다들 화이팅! 🚀" }, { "title": "React의 useCallback() 이거 써봐", "url": "/posts/React%EC%9D%98-useCallback()-%EC%9D%B4%EA%B1%B0-%EC%8D%A8%EB%B4%90/", "categories": "React", "tags": "useCallback", "date": "2023-08-19 20:00:00 +0900", "snippet": "안녕하세요! 오늘은 아주아주 중요한 주제로 찾아왔어요. React를 사용하면서 useCallback()이라는 훅에 대해 아십니까? useState나 useEffect도 좋지만, useCallback도 반드시 알아야 할 중요한 친구입니다! 😉함수 메모이제이션 🌍먼저 이 useCallback이 뭐냐고요? 간단하게 말하자면, 함수를 기억하게 해주는 훅이에요. 😎 컴포넌트가 다시 그려질 때마다 함수를 새로 만들면 굉장히 비효율적이거든요.const memoizedCallback = useCallback(함수, 배열);이런 식으로 쓰면, 배열 안의 값이 바뀌지 않는 한 같은 함수를 계속 쓸 수 있어요! 🎉자바스크립트에서의 함수 동등성 문제 💡자바스크립트에서 함수는 객체로 취급되기 때문에, 동등성 비교는 메모리 주소를 기반으로 해요. 그래서 같은 코드의 함수도 ===로 비교하면 false가 나와버리는 거죠!그래서 이게 왜 중요하냐고요? 함수를 다른 함수나 컴포넌트에게 전달할 때, 이 동등성 문제 때문에 성능 문제가 발생할 수 있어요.useCallback과 useEffect의 환상의 콤비 💫useEffect 같은 경우도, 의존 배열이 바뀌지 않으면 함수를 다시 호출하지 않아요. 그런데 여기서 문제가 생겨요! 함수는 컴포넌트가 랜더링될 때마다 새로운 참조값으로 변경되니까요. 그래서 이런 문제를 피하려면 useCallback을 써서 함수의 참조값을 일정하게 유지시키는 거죠!React.memo와 함께 쓰면 더 좋아 🌟React.memo()는 뭐냐고요? 이것도 역시 성능 최적화에 도움을 주는 친구입니다. useCallback()과 함께 쓰면 자식 컴포넌트의 불필요한 랜더링을 줄일 수 있어요! 🙌오늘은 이렇게 useCallback에 대해서 알아봤어요! 이제 이 친구를 적극 활용해서 앱을 더 빠르게 만들어보아요! 🚀🚀🚀재미있게 읽어주셔서 감사합니다! 😊👏" }, { "title": "React의 ref prop과 useRef() 완전 정복하기", "url": "/posts/React%EC%9D%98-ref-prop%EA%B3%BC-useRef()-%EC%99%84%EC%A0%84-%EC%A0%95%EB%B3%B5%ED%95%98%EA%B8%B0/", "categories": "React", "tags": "prop", "date": "2023-08-18 20:00:00 +0900", "snippet": "안녕하세요, 리액트 마스터가 되고 싶은 여러분! 🎉 오늘은 리액트에서 실제 HTML 엘리먼트에 접근하는 방법을 살펴볼 거예요. 그럼 이제 고고씽! 🚴‍♀️ref prop의 기본 개념 👨‍🏫ref prop은 HTML 엘리먼트의 레퍼런스(주소 같은 거)를 변수에 담아줘요. 그래서 이 변수를 통해 HTML 엘리먼트를 마음대로 조종할 수 있답니다! 🎮useRef()는 무엇인가요? 🎣useRef()는 리액트의 훅(hook) 중 하나예요. 함수형 컴포넌트에서 ref prop을 쓰려면 이 친구를 사용해야 해요. 코드를 살펴볼까요? 🧐import React, { useRef } from \"react\";function AwesomeInput() { const inputRef = useRef(null); const handleClick = () =&gt; { inputRef.current.focus(); } return ( &lt;&gt; &lt;input ref={inputRef} /&gt; &lt;button onClick={handleClick}&gt;포커스 주기&lt;/button&gt; &lt;/&gt; );}위 코드에서 보시다시피, inputRef라는 변수에 HTML 엘리먼트의 레퍼런스가 담기게 돼요. 그럼 이제 inputRef.current로 input 엘리먼트를 조종할 수 있어요! 🕹다양한 엘리먼트 제어하기 🎭ref prop은 input 엘리먼트 외에도 다양한 엘리먼트에 사용할 수 있어요. 예를 들어 오디오나 비디오 엘리먼트도 쉽게 조종할 수 있죠. 그러니까 복잡한 애플리케이션에서도 유용하게 사용할 수 있어요! 🌟그래도 조심해야 할 점! ⚠️마지막으로, 리액트는 선언형 프로그래밍을 기반으로 하기 때문에, 꼭 필요한 경우가 아니면 ref prop을 쓰지 않는 게 좋아요. 그래도 사용할 때는 이 포스트를 잘 참고하시면 된답니다! 😉마무리 🎬이렇게 하면 리액트에서 HTML 엘리먼트를 제어하는 ref prop과 useRef()에 대해 알게 되셨을 거에요. 그럼 저는 다음글에서 뵙겠습니다. 감사합니다!" }, { "title": "React와 Material UI로 깔끔한 테이블 만들기", "url": "/posts/React%EC%99%80-Material-UI%EB%A1%9C-%EA%B9%94%EB%81%94%ED%95%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "React", "tags": "MaterialUI", "date": "2023-08-17 20:00:00 +0900", "snippet": "테이블을 만들어보자! 🚀저희는 여러분에게 React와 Material UI로 완벽하게 빛나는 테이블을 만드는 방법을 알려드릴 겁니다. 그래서 여러분은 이 글을 읽고 나면, 테이블 UI를 마스터 할 수 있을 거예요! 🌟필수 구성 요소테이블을 만들려면 어떤 컴포넌트가 필요할까요? 그건 바로 Table, TableBody, TableCell, TableContainer, TableHead, TableRow입니다. 이 컴포넌트들을 모아서 @material-ui/core 패키지에서 한 번에 불러옵니다. 코드는 이렇게 생겼어요:import { Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Paper,} from \"@material-ui/core\";테스트 데이터 만들기: faker의 마법 🎩여러분은 테스트 데이터가 필요합니다. 그래서 faker 라이브러리를 이용해서 다양한 사용자 정보를 생성합니다. faker가 없다면 테스트 데이터를 직접 입력해야 하죠, 그건 너무 지루해요! 🙄 코드는 아래와 같습니다.import faker from \"faker/locale/ko\";faker.seed(123);const users = Array(53).fill().map(() =&gt; ({ id: faker.random.uuid(), name: faker.name.lastName() + faker.name.firstName(), email: faker.internet.email(), phone: faker.phone.phoneNumber(),}));기본 테이블 작성하기: 먼저 기초부터! 🏗️기본적인 테이블은 어떻게 만들까요? 그건 바로 TableHead와 TableBody를 이용해서 각각 레이블과 데이터를 표시하면 돼요. 아, 너무 쉬워서 놀랐죠? 😲 코드는 이렇게 작성합니다.function UserTable() { return ( &lt;TableContainer component={Paper}&gt; &lt;Table size=\"small\"&gt; &lt;TableHead&gt; &lt;TableRow&gt; &lt;TableCell&gt;No&lt;/TableCell&gt; &lt;TableCell align=\"right\"&gt;Name&lt;/TableCell&gt; &lt;TableCell align=\"right\"&gt;Email&lt;/TableCell&gt; &lt;TableCell align=\"right\"&gt;Phone&lt;/TableCell&gt; &lt;/TableRow&gt; &lt;/TableHead&gt; &lt;TableBody&gt; {users.map(({ id, name, email, phone }, i) =&gt; ( &lt;TableRow key={id}&gt; &lt;TableCell&gt;{i + 1}&lt;/TableCell&gt; &lt;TableCell align=\"right\"&gt;{name}&lt;/TableCell&gt; &lt;TableCell align=\"right\"&gt;{email}&lt;/TableCell&gt; &lt;TableCell align=\"right\"&gt;{phone}&lt;/TableCell&gt; &lt;/TableRow&gt; ))} &lt;/TableBody&gt; &lt;/Table&gt; &lt;/TableContainer&gt; );}페이징도 있어요: 페이지 넘기기로 편안함을! 📖많은 데이터를 보여주려면 페이징이 필요해요. Material UI에서는 TablePagination 컴포넌트를 제공합니다. 덕분에 페이징도 쉬워요. 헤헤 😄import { TableFooter, TablePagination,} from \"@material-ui/core\";// ...이하 생략이렇게 하면 여러분도 테이블 마스터가 될 수 있습니다! React와 Material UI로 만든 테이블, 어때요? 나머지 활용은 여러분의 손에 달렸어요! 🎉🎉" }, { "title": "React에서 웹 스토리지와 친해지기", "url": "/posts/React%EC%97%90%EC%84%9C-%EC%9B%B9-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EC%99%80-%EC%B9%9C%ED%95%B4%EC%A7%80%EA%B8%B0/", "categories": "React", "tags": "웹스토리지", "date": "2023-08-16 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 “React에서 웹 스토리지로 상태 유지하기”라는 정말 흥미로운 주제로 가득 채운 이야기를 해볼까 해요. 어떤가요, 두근두근 하시죠? 🤩상태 관리의 고민, 끝! 🤔알고 계시죠? React에는 useState()라는 훅이 있어요. 이걸로 상태 관리를 정말 쉽게 할 수 있습니다. 하지만 뒤로가기를 누르거나 새로고침을 하면 뭐가 돼요? 🥺 그렇죠, 모든 정보가 날라가버린답니다. 이제 그 문제를 해결할 비결을 공유하겠습니다.웹 스토리지 소개 📦웹 스토리지는 브라우저에 데이터를 저장하는 방법이에요. 간단히 말하면, 데이터를 저장해서 다음에 또 쓸 수 있게 해주는 아주 똑똑한 친구랍니다! 😎상태를 웹 스토리지에 저장하기 📝React의 useEffect() 훅을 쓰면 상태 정보를 웹 스토리지에 저장할 수 있어요. 코드를 보면서 설명하겠습니다.// PersistentCounter.jsximport React, { useState, useEffect } from \"react\";function Counter() { const [count, setCount] = useState( () =&gt; JSON.parse(window.localStorage.getItem(\"count\")) || 0 ); useEffect(() =&gt; { window.localStorage.setItem(\"count\", JSON.stringify(count)); }, [count]); return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{count}&lt;/button&gt;;}아주 간단하죠? 이렇게 useEffect()를 써서 상태 정보를 웹 스토리지에 저장합니다. ✨커스텀 훅으로 중복 줄이기 🎉여러 컴포넌트에서 웹 스토리지를 사용하려면, 커스텀 훅을 만들어 봅시다.// useLocalStorage.jsimport { useState, useEffect } from \"react\";function useLocalStorage(key, initialState) { const [state, setState] = useState( () =&gt; JSON.parse(window.localStorage.getItem(key)) || initialState ); useEffect(() =&gt; { window.localStorage.setItem(key, JSON.stringify(state)); }, [key, state]); return [state, setState];}이제 이 훅을 사용해서 다른 컴포넌트에서도 상태를 웹 스토리지에 저장할 수 있답니다!graph TD; A[useState] --&gt; B[useEffect]; B --&gt; C[웹 스토리지]; C --&gt; D[커스텀 훅]; D --&gt; E[재사용];마무리 🎉여러분, 웹 스토리지와 React 훅을 이용해 상태를 유지하는 방법을 배웠습니다! 이제는 뒤로가기 버튼이나 새로고침을 눌러도 두렵지 않죠? 😎" }, { "title": "React에서 외부 스크립트 삽입 마스터 되기", "url": "/posts/React%EC%97%90%EC%84%9C-%EC%99%B8%EB%B6%80-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%82%BD%EC%9E%85-%EB%A7%88%EC%8A%A4%ED%84%B0-%EB%90%98%EA%B8%B0/", "categories": "React", "tags": "외부스크립트", "date": "2023-08-15 20:00:00 +0900", "snippet": "들어가며: 외부 스크립트, 왜 그렇게 까다로운 거야? 🤔안녕하세요! 이 글을 찾아주신 분들은 분명 React를 다룰 때 외부 스크립트가 어떻게든 필요하셨을 거라고 생각합니다. 물론 npm으로 다 해결될 수 있다면 좋겠지만, 현실은 그렇게 다정하지 않죠? 🙃 그래서 오늘은 ‘외부 스크립트를 어떻게 효율적으로 불러올까?’라는 근본적인 질문에 답을 해보도록 하겠습니다.바로가기! index.html 파일에 script 태그 추가하기 🚀제일 쉬운 방법부터 시작해봅시다. public 폴더 안에 있는 index.html 파일을 열고 &lt;script&gt; 태그를 추가해주면 됩니다. 이렇게 하면 React 앱이 아닌 일반 웹사이트처럼 외부 스크립트를 불러올 수 있습니다.예시 코드:&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script async src=\"https://unpkg.com/lodash\"&gt;&lt;/script&gt;하지만 그렇게 간단하지 않았습니다 😅위의 방법은 간단하긴 하지만, 외부 자바스크립트가 필요한 컴포넌트에서만 선택적으로 불러올 수 없다는 큰 단점이 있습니다. 그리고 이건 자원 낭비의 큰 원인이 될 수 있어요. 🚫Vanilla 자바스크립트로 문제 해결하기 🍦아래의 코드처럼 vanilla 자바스크립트로 문제를 해결할 수 있습니다. 이렇게 하면 원하는 위치에 외부 스크립트를 동적으로 삽입할 수 있습니다.const script = document.createElement(\"script\");script.src = \"https://unpkg.com/lodash\";script.async = true;document.body.appendChild(script);React 컴포넌트에서는 어떻게? 🤷‍♂️React에서는 useEffect 훅을 사용하여 외부 스크립트를 불러올 수 있습니다. 아래는 그 예시입니다.import { useEffect } from \"react\";function Input() { useEffect(() =&gt; { const script = document.createElement(\"script\"); script.src = \"https://unpkg.com/lodash\"; script.async = true; document.body.appendChild(script); }); return &lt;input /&gt;;}중복 삽입은 No-No 🙅‍♀️코드를 이렇게 작성하면 &lt;input&gt; 요소에 글자를 입력할 때마다 동일한 &lt;script&gt; 요소가 중복해서 삽입됩니다. 이 문제를 해결하려면 useEffect의 두 번째 인자로 빈 배열을 전달해야 합니다.useEffect(() =&gt; { // ... 코드 생략}, []);마무리: 스크립트 마스터가 되어보자! 🎓React에서 외부 스크립트를 다루는 방법은 여러 가지가 있을 수 있지만, 위에서 소개한 방법들은 가장 기본적이면서도 효율적입니다. 이제 여러분도 외부 스크립트를 마스터할 준비가 되셨다고 확신합니다! 🥳" }, { "title": "React에서 useRef 훅을 마스터하자!", "url": "/posts/React%EC%97%90%EC%84%9C-useRef-%ED%9B%85%EC%9D%84-%EB%A7%88%EC%8A%A4%ED%84%B0%ED%95%98%EC%9E%90!/", "categories": "React", "tags": "useRef", "date": "2023-08-13 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 React Hooks 중에서도 꼭 알아야 할 useRef에 대해 한 번 제대로 파헤쳐봅시다. 이녀석은 그냥 지나칠 수 없죠!useRef가 뭐에요? 🤷‍♀️useRef는 React Hooks 중 하나로, 이녀석은 뭐든지 기억해낼 수 있는 능력이 있어요. 변덕스러운 변수값들을 다룰 때 정말로 유용하죠. 상태(state)가 변경될 때마다 컴포넌트를 재랜더링하는 React에서, 렌더링에 영향을 미치지 않으면서도 데이터를 유지할 수 있게 해줍니다.예제로 알아보자! 🎯카운터 버튼 예제 🖲️변수를 이용해서 카운터를 만들어볼게요. 그냥 단순 클릭 카운터입니다.import React, { useState } from \"react\";function Counter() { const [count, setCount] = useState(0); return ( &lt;&gt; &lt;p&gt;{count}번 클릭하셨습니다.&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;클릭&lt;/button&gt; &lt;/&gt; );}아주 쉽죠? 😎 그런데 만약 이 카운터를 자동으로 동작하게 만들려면 어떻게 해야 할까요? setInterval을 이용해서 자동 카운터를 만들어봅시다.import React, { useState, useEffect } from \"react\";function AutoCounter() { const [count, setCount] = useState(0); useEffect(() =&gt; { const intervalId = setInterval(() =&gt; setCount(count + 1), 1000); return () =&gt; clearInterval(intervalId); }, []); return &lt;p&gt;자동 카운트: {count}&lt;/p&gt;;}useRef를 활용한 카운터 🎰자, 이제 useRef의 무대입니다! 위에서 만든 자동 카운터를 시작/정지 버튼을 이용하여 제어해봅시다.import React, { useState, useEffect, useRef } from \"react\";function SuperCounter() { const [count, setCount] = useState(0); const intervalId = useRef(null); const startCounter = () =&gt; { intervalId.current = setInterval(() =&gt; setCount(count + 1), 1000); }; const stopCounter = () =&gt; { clearInterval(intervalId.current); }; return ( &lt;&gt; &lt;p&gt;🦸‍♀️ 슈퍼 카운터: {count}&lt;/p&gt; &lt;button onClick={startCounter}&gt;🚀 시작&lt;/button&gt; &lt;button onClick={stopCounter}&gt;🛑 정지&lt;/button&gt; &lt;/&gt; );}여기서 useRef가 도와준 건, startCounter 함수와 stopCounter 함수가 intervalId를 공유할 수 있게 해준 것이죠! 그래서 자유롭게 카운터를 시작하거나 멈출 수 있어요. 멋지죠? 😆마무리 🎉그래서 오늘 배운 것은 useRef가 뭐하는 녀석인지, 그리고 이 친구를 어떻게 활용할 수 있는지 알아봤어요. 기억하세요, 프로그래밍에서는 경험이 최고의 선생님이에요! 코드를 많이 작성해보면서 useRef의 놀라운 능력을 체험해보세요! 다음에 또 뵙겠습니다! 안녕! 👋" }, { "title": "React의 Uncontrolled Components 이해하기", "url": "/posts/React%EC%9D%98-Uncontrolled-Components-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/", "categories": "React", "tags": "Uncontrolled", "date": "2023-08-12 20:00:00 +0900", "snippet": "안녕하세요, 여러분 오늘은 React에서 Uncontrolled Components를 사용하는 신비한 방법에 대해 알아볼 겁니다. ✨초보자를 위한 Uncontrolled Components 101 🎓먼저, Uncontrolled Components가 무엇인지 알아봅시다. React는 Controlled Components와 Uncontrolled Components라는 두 가지 컴포넌트를 제공해요. Controlled는 말 그대로 제어를 React가 다 해주는 녀석이고, Uncontrolled는 브라우저가 자동으로 해주는 친구입니다! 이번 글에서는 후자에 집중할 거에요!마법의 주문: DOM API 🧙‍♂️첫 번째 방법은 마치 React가 없는 것처럼, 순수한 자바스크립트의 DOM API를 사용하는 거에요! 아래에 있는 코드 예시는 제출(submit) 이벤트에서 양식의 내부 값을 가져오는 방법입니다.function Form() { const handleSubmit = (event) =&gt; { event.preventDefault(); const { title: { value: input }, country: { value: select }, description: { value: textArea }, } = event.target; alert(JSON.stringify({ input, select, textArea })); }; return ( &lt;form onSubmit={handleSubmit}&gt; {/*...*/} &lt;/form&gt; );}주의! 🚨 여기서는 defaultValue와 defaultChecked prop을 사용해야 해요. 그렇지 않으면, 값이 고정되어 변경이 안 되거든요!React 답게: useState() 후크 사용하기 🎣두 번째 방법은 useState 후크를 사용하는 것입니다. 이렇게 하면 React 스타일로 상태 관리를 할 수 있어요! 아래의 코드를 봅시다.import { useState } from \"react\";function Form() { const [input, setInput] = useState(null); const handleSubmit = (event) =&gt; { event.preventDefault(); alert(JSON.stringify({ input: input?.value })); }; return ( &lt;form onSubmit={handleSubmit}&gt; &lt;input name=\"title\" defaultValue=\"\" ref={(element) =&gt; setInput(element)} /&gt; {/*...*/} &lt;/form&gt; );}여기서는 ref prop을 이용하여 각 HTML 요소에 대한 참조를 얻어옵니다. 이 참조를 이용해서 상태를 업데이트해요!이해하기 쉬운 다이어그램 📊sequenceDiagramUser-&gt;&gt;Form: 사용자가 폼을 작성Form-&gt;&gt;handleSubmit: 제출 버튼 클릭handleSubmit-&gt;&gt;React: 상태 업데이트 요청React-&gt;&gt;Form: 상태 업데이트 완료Form-&gt;&gt;User: 결과 표시마치며 🎉요약하자면, Uncontrolled Components는 React에서도, React 없이도 사용할 수 있는 유연한 친구입니다. DOM API로도, useState 후크로도 상태 관리가 가능해요! 😎 오늘도 즐거운 코딩 되세요! 🌈 Happy Coding! 🚀" }, { "title": "React에서 useReducer Hook을 이용한 상태 관리 마스터", "url": "/posts/React%EC%97%90%EC%84%9C-useReducer-Hook%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC-%EB%A7%88%EC%8A%A4%ED%84%B0/", "categories": "React", "tags": "useReducer", "date": "2023-08-11 20:00:00 +0900", "snippet": "안녕하세요, React 개발자 여러분! 😀 오늘은 useReducer Hook을 이용한 상태 관리에 대해 자세히 알아볼거예요.왜 useReducer가 중요한가요? 🤔useState가 있어도 왜 useReducer가 필요한지 궁금해하시는 분들을 위해 말씀드리겠습니다. useState는 간단하고 빠르게 상태를 관리할 수 있지만, 복잡한 로직이나 여러 상태 간의 연계성을 다룰 때는 한계가 있어요. useReducer는 이런 한계를 깨고 복잡한 상태를 단순하게 만들어 줍니다!useReducer의 기본 문법 👨‍🏫const [state, dispatch] = useReducer(reducer, initialState);여기서 reducer는 상태와 행동을 받아 새 상태를 반환하는 함수입니다. initialState는 초기 상태값을 설정하는 곳이죠. 그리고 dispatch 함수로 행동을 발생시키면, reducer가 새 상태로 업데이트 해줍니다.카운터 예제로 이해하기 🎯이제부터 useReducer를 이용해 간단한 카운터 앱을 만들어 볼게요.import React, { useReducer } from \"react\";const initialState = { count: 0 };function reducer(state, action) { switch (action.type) { case \"INCREMENT\": return { count: state.count + 1 }; case \"DECREMENT\": return { count: state.count - 1 }; default: throw new Error(\"Unsupported action\"); }}function Counter() { const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; &lt;h2&gt;{state.count}&lt;/h2&gt; &lt;button onClick={() =&gt; dispatch({ type: \"INCREMENT\" })}&gt;증가&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: \"DECREMENT\" })}&gt;감소&lt;/button&gt; &lt;/&gt; );}예제는 간단하게 만들어봤지만 여기서 INCREMENT나 DECREMENT 같은 행동에 추가적인 데이터를 넣어 복잡한 상태 변화도 쉽게 할 수 있답니다!복잡한 상태 관리하기 🎩아래 예제에선 카운트의 최대, 최소 값을 정해봤어요.function reducer(state, action) { switch (action.type) { case \"INCREMENT\": return state.count &lt; 10 ? { count: state.count + 1 } : state; case \"DECREMENT\": return state.count &gt; 0 ? { count: state.count - 1 } : state; default: throw new Error(\"Unsupported action\"); }}이렇게 하면 카운트가 0보다 작아지거나 10보다 커지는 것을 막을 수 있죠.최종 코드 요약 📝최종적으로 모든 코드를 다 이해했다면, 이제 당신은 useReducer를 마스터한 것이나 다름 없습니다. 축하해요! 🎉graph TD; A[useReducer 시작] --&gt; B[상태와 행동 정의]; B --&gt; C[reducer 함수 생성]; C --&gt; D[dispatch로 행동 발생]; D --&gt; E[상태 업데이트]; E --&gt; F[useReducer 완료];이상으로 React에서 useReducer를 사용하여 복잡한 상태 관리를 할 수 있음을 알려 드렸습니다. 여러분도 이제 상태 관리 고수가 되어보세요! 🥳" }, { "title": "React 훅 이용하여 API 요청의 비밀 레시피 공개!", "url": "/posts/React-%ED%9B%85-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-API-%EC%9A%94%EC%B2%AD%EC%9D%98-%EB%B9%84%EB%B0%80-%EB%A0%88%EC%8B%9C%ED%94%BC-%EA%B3%B5%EA%B0%9C!/", "categories": "React", "tags": "React훅", "date": "2023-08-10 20:00:00 +0900", "snippet": "들어가기 전에안녕하세요, 오늘은 여러분에게 React 훅을 이용한 API 요청의 비밀 레시피를 제공해 드릴 겁니다. 이미 잘 알고 계신 내용일지 모르지만, 우리의 레시피는 다르답니다!요리의 첫 단계: useState와 useEffect 준비하기 🥄어떤 요리든 준비물이 중요하죠. React에서 API 요청을 다루려면 useState와 useEffect 두 가지 훅을 준비해야 해요. 아래와 같이 간단하게 코드를 작성할 수 있어요.import React, { useState, useEffect } from \"react\";요리재료 넣기: 데이터를 저장할 상태 만들기 🍲상태는 요리재료와 같아요. 빈 상태부터 시작해서 API 호출로 데이터를 채워넣죠.const [data, setData] = useState(null);const [loading, setLoading] = useState(true);const [error, setError] = useState(null);요리 시작: useEffect로 API 요청하기 🔥그럼 이제 본격적으로 API를 요청해 볼까요? useEffect는 여기서 주인공입니다.useEffect(() =&gt; { fetch('API_주소') .then((response) =&gt; response.json()) .then((data) =&gt; setData(data)) .catch((error) =&gt; setError(error)) .finally(() =&gt; setLoading(false));}, []);미식가를 위한 Tip: 커스텀 훅 만들기 🍱만약 다양한 요리, 즉 다양한 컴포넌트에서 같은 API를 요청해야 한다면? 그럴 땐 커스텀 훅을 만들면 좋아요.graph LR 컴포넌트1[컴포넌트 1] --&gt; 커스텀훅 컴포넌트2[컴포넌트 2] --&gt; 커스텀훅 컴포넌트3[컴포넌트 3] --&gt; 커스텀훅function useFetch(url) { const [data, setData] = useState(null); const [loading, setLoading] = useState(true); const [error, setError] = useState(null); useEffect(() =&gt; { fetch(url) .then((response) =&gt; response.json()) .then((data) =&gt; setData(data)) .catch((error) =&gt; setError(error)) .finally(() =&gt; setLoading(false)); }, [url]); return { data, loading, error };}요리의 결실: 끝난 후 상태 확인하기 🍎그래서 이렇게 만든 요리, 아니 코드를 어떻게 확인하나요?const { data, loading, error } = useFetch('API_주소');if (loading) return &lt;p&gt;로딩 중...&lt;/p&gt;;if (error) return &lt;p&gt;오류 발생! 😱&lt;/p&gt;;return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;요약과 꿀팁 🍯오늘은 React 훅을 이용해서 API 요청의 비밀 레시피를 공개했어요. 그리고 덤으로 커스텀 훅까지 배웠죠! 이제 여러분도 API 요청 마스터가 되셨다고 자부해도 됩니다!React의 무한한 세계, 오늘도 함께 탐험해 주셔서 감사합니다! 🌈 다음에 또 새로운 주제로 만나요!뿅! 🎉" }, { "title": "React 컴포넌트로 체크박스 마스터 되기", "url": "/posts/React-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A1%9C-%EC%B2%B4%ED%81%AC%EB%B0%95%EC%8A%A4-%EB%A7%88%EC%8A%A4%ED%84%B0-%EB%90%98%EA%B8%B0/", "categories": "React", "tags": "리액트체크박스", "date": "2023-08-09 20:00:00 +0900", "snippet": "들어가며: 체크박스, 그 놀라운 비밀 🤫안녕하세요, 여러분! 오늘은 너무나도 신나는 주제로 찾아왔어요. 그것은 바로 ‘체크박스’입니다! 💥 여러분은 체크박스를 얼마나 잘 아시나요? 오늘은 React에서 체크박스를 어떻게 끝장내는지 알려 드릴게요!체크박스로 할 수 있는 일체크박스는 신기한 녀석이에요. 이용약관 동의부터 마케팅 수신 동의까지, 체크박스는 여러분과 사용자 사이의 ‘예’ 혹은 ‘아니오’를 결정합니다. 😊체크박스 기본 컴포넌트 만들기 🛠️function Checkbox({ children, disabled, checked, onChange }) { return ( &lt;label&gt; &lt;input type=\"checkbox\" disabled={disabled} checked={checked} onChange={({ target: { checked } }) =&gt; onChange(checked)} /&gt; {children} &lt;/label&gt; );}여기서 children은 체크박스 옆에 들어갈 텍스트, disabled는 비활성화 여부, checked는 체크 여부, onChange는 체크 상태가 바뀔 때 실행되는 함수입니다.체크박스를 이용한 회원 가입 UI 🎨import React from \"react\";import Checkbox from \"./Checkbox\";function App() { const [service, setService] = React.useState(false); const [marketing, setMarketing] = React.useState(false); return ( &lt;article&gt; &lt;header&gt; &lt;h3&gt;체크박스 활용&lt;/h3&gt; &lt;/header&gt; &lt;Checkbox checked={service} onChange={setService}&gt; (필수) 서비스 이용약관 &lt;/Checkbox&gt; &lt;Checkbox checked={marketing} onChange={setMarketing}&gt; (선택) 마케팅 수신 &lt;/Checkbox&gt; &lt;footer&gt; &lt;button disabled={!service}&gt;회원 가입&lt;/button&gt; &lt;/footer&gt; &lt;/article&gt; );}회원 가입 버튼은 서비스 이용약관에 동의했을 때만 활성화됩니다. 🎉여러 체크박스 관리하기 🌈import CheckboxContext from \"./CheckboxContext\";function CheckboxGroup({ label, children, disabled: groupDisabled, values, onChange}) { // ... (코드 생략) return ( &lt;fieldset&gt; &lt;legend&gt;{label}&lt;/legend&gt; &lt;CheckboxContext.Provider value=&gt; {children} &lt;/CheckboxContext.Provider&gt; &lt;/fieldset&gt; );}CheckboxGroup 컴포넌트는 여러 개의 체크박스를 하나로 묶어줍니다. label로 그룹의 이름을 표시하고, CheckboxContext.Provider를 통해 정보를 공유합니다.완성! 😎이렇게 해서 우리는 React에서 체크박스 컴포넌트를 마스터했습니다! 이제 여러분도 체크박스로 웹사이트를 더 즐겁게 만들 수 있겠죠?" }, { "title": "React v18과 Suspense의 화려한 등장", "url": "/posts/React-v18%EA%B3%BC-Suspense%EC%9D%98-%ED%99%94%EB%A0%A4%ED%95%9C-%EB%93%B1%EC%9E%A5/", "categories": "React", "tags": "Suspense", "date": "2023-08-08 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 리액트 세계에서 소문만 무성하던, 아니, 팬들이 절박하게 기다려온 React v18의 엄청난 기능, Suspense에 대해 이야기할 예정입니다. 응, 드디어 이 시간이 왔어요! 🎉Suspense? 그게 뭐에요? 🤔Suspense는 2018년에 첫 선을 보이고, React v16.6에서 실험적으로 추가되었습니다. “실험적으로”라니, 과학자도 놀랄 법한 용어죠? 😆 Suspense는 리액트에서 아주 큰 변화를 가져올 기능 중 하나랍니다.Suspense가 왜 대단한 건가요? 🌟Suspense를 사용하면 컴포넌트 랜더링을 어떤 작업이 끝날 때까지 ‘잠깐!’ 멈춰둘 수 있어요. 마치 마법사가 주문을 외우기 전까지 기다리는 거죠. 🧙‍♂️ 네트워크를 통해 데이터를 가져오는 작업이 대표적입니다.Suspense는 어떻게 동작하나요? 🛠️sequenceDiagram User-&gt;&gt;React: 페이지 로딩 React-&gt;&gt;Suspense: 데이터 필요해! Suspense--&gt;&gt;API: 데이터 주세요 API--&gt;&gt;Suspense: 데이터 전달 Suspense-&gt;&gt;React: 다 됐어, 랜더링 해! React-&gt;&gt;User: 완성된 페이지 보여줌Suspense는 랜더링을 ‘일시 중지’하고, 필요한 데이터가 준비될 때까지 기다린다음, 랜더링을 이어서 진행해요.&lt;Suspense fallback={&lt;Spinner /&gt;}&gt; &lt;UserList /&gt;&lt;/Suspense&gt;Suspense 사용 전과 후의 차이는? 🤷‍♀️Suspense를 사용하기 전에는 주로 componentDidMount()나 useEffect() 훅을 사용했어요. 그런데 Suspense가 등장하면서 더 쉽고 깔끔하게 비동기 작업을 관리할 수 있게 되었답니다!Suspense 사용 전 코드 예제 🙄useEffect(() =&gt; { fetch(`https://jsonplaceholder.typicode.com/users/${userId}`) .then((response) =&gt; response.json()) .then((user) =&gt; { setUser(user); });}, []);Suspense 사용 후 코드 예제 😎&lt;Suspense fallback={&lt;Spinner /&gt;}&gt; &lt;UserList /&gt;&lt;/Suspense&gt;놀라웠죠? Suspense를 사용하면 코드가 훨씬 간결해지고 관리하기 쉬워져요.마치며 🎉Suspense는 리액트의 미래를 바꿀 거대한 파급력을 가진 기능이에요. Suspense를 아직 사용해보지 않았다면, 이제라도 시도해보는 건 어떨까요? 🚀 이상 React v18의 놀라운 Suspense에 대한 이야기였습니다! 다음에 또 뵙겠습니다, 안녕! 👋😃" }, { "title": "React Testing Library로 비동기 컴포넌트 테스트", "url": "/posts/React-Testing-Library%EB%A1%9C-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8/", "categories": "React", "tags": "ReactTestingLibrary", "date": "2023-08-07 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 비동기 컴포넌트를 테스트하는 방법을 알아볼 거에요. 😆 React Testing Library가 얼마나 대단한지, 그리고 어떻게 비동기 컴포넌트를 쉽게 테스트할 수 있는지 알려드릴게요!예제 컴포넌트: 컴포넌트의 비밀 😎먼저, 테스트의 주인공인 &lt;Switch/&gt; 컴포넌트에 대해 알아보죠. 이 친구는 ‘ON’과 ‘OFF’ 버튼으로 변신해요. 버튼을 누르면 ON, OFF가 번갈아 나타나는 마법을 보여줍니다! 그리고 상태를 바꾸는 데에는 0.5초가 걸려요. 와우, 이거 다 테스트해야 한다니, 두근두근하죠? 😲import React, { useState } from \"react\";function Switch() { const [disabled, setDisabled] = useState(false); const [on, setOn] = useState(false); const handleClick = () =&gt; { setDisabled(true); setTimeout(() =&gt; { setOn(!on); setDisabled(false); }, 500); }; return ( &lt;button disabled={disabled} onClick={handleClick}&gt; {on ? \"ON\" : \"OFF\"} &lt;/button&gt; );}export default Switch;초기 상태 테스트: 첫 만남의 중요성 🌟첫 만남은 중요하죠? &lt;Switch/&gt; 컴포넌트도 처음에는 ‘OFF’ 상태를 보여주면서 클릭이 가능해야 해요. 이 부분을 테스트하기 위해 React Testing Library의 기본 함수를 사용할 거에요.test(\"OFF 버튼은 초기에 활성화 되어 있어야 한다\", () =&gt; { render(&lt;Switch /&gt;); const button = screen.getByRole(\"button\"); expect(button).toHaveTextContent(\"OFF\"); expect(button).toBeEnabled();});동기 상태 변경 테스트: 버튼 누르면 어떻게 될까요? 🤔버튼을 누르면 disabled 상태가 ‘true’가 되어야 하죠. 이걸 테스트하는 것은 아주 쉬워요!test(\"버튼을 누르면 비활성화 되어야 한다\", () =&gt; { render(&lt;Switch /&gt;); const button = screen.getByRole(\"button\"); userEvent.click(button); expect(button).toBeDisabled();});비동기 상태 변경 테스트: 시간을 두고 봐야 더 재미있어요! 🕒0.5초 동안 버튼 상태가 바뀌는 것을 테스트하려면 어떻게 해야 할까요? 바로 findByRole() 함수를 사용해서 해결할 수 있어요!test(\"버튼을 누르면 ON 상태가 활성화 되어야 한다\", async () =&gt; { render(&lt;Switch /&gt;); userEvent.click(screen.getByRole(\"button\")); const button = await screen.findByRole(\"button\", { name: /on/i }); expect(button).toBeInTheDocument(); expect(button).toBeEnabled();});이제 어떻게 하면 비동기 상태의 컴포넌트를 쉽게 테스트할 수 있는지 알게 되셨죠? 🎉비동기 테스트의 작은 팁: async와 await 잊지 마세요! 🌈비동기 테스트를 할 때는 async와 await 키워드를 사용하면 성공을 거둘 수 있어요. 그래서 반드시 이 키워드를 잘 활용해 보세요!sequenceDiagram User-&gt;&gt;+Switch Component: Click Switch Component-&gt;&gt;+Test: Change State Test-&gt;&gt;Switch Component: Check if state is changed Test--&gt;&gt;User: Test Passed이렇게 해서 React Testing Library로 비동기 컴포넌트를 테스트하는 방법을 마스터했네요! 👏 다음에 또 재미있는 주제로 찾아뵐게요. 여러분, 화이팅! 💪😎" }, { "title": "React Table로 데이터를 쉽고 멋지게", "url": "/posts/React-Table%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%89%BD%EA%B3%A0-%EB%A9%8B%EC%A7%80%EA%B2%8C/", "categories": "React", "tags": "ReactTable", "date": "2023-08-06 20:00:00 +0900", "snippet": "소개: React Table이란 무엇인가요?안녕하세요, 여러분! 오늘은 ‘테이블’을 다룰 예정이에요. 리액트를 사용하여 편리하고 멋진 테이블을 만들고 싶다면, React Table을 꼭 알아봐야 합니다! 이 라이브러리는 정렬, 검색 같은 여러 기능을 쉽게 추가할 수 있게 도와줍니다. ✨시작하기 전에: 필요한 준비물 📦먼저, 터미널에서 react-table 패키지를 설치해 줍니다. 그리고 faker 라이브러리도 설치해 주세요. 이건 랜덤한 테스트 데이터를 만들어주는 역할을 합니다.npm install react-table faker첫 번째 단계: 랜덤 데이터 생성하기 🎲랜덤 데이터를 만드는 건 정말 쉬워요. faker 라이브러리를 이용하면 몇 줄 안에 끝납니다.import faker from \"faker/locale/ko\";faker.seed(100);const data = Array(53).fill().map(() =&gt; ({ name: faker.name.lastName() + faker.name.firstName(), email: faker.internet.email(), phone: faker.phone.phoneNumber(),}));이렇게 하면 이름, 이메일, 전화번호가 들어간 53개의 랜덤 데이터가 생깁니다.두 번째 단계: 테이블 만들기 🛠️기본 테이블 만들기React로 기본 테이블을 만들어 볼게요. Table 컴포넌트를 만들어서 columns과 data를 props로 받습니다.import React from \"react\";function Table({ columns, data }) { return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; {columns.map((column) =&gt; ( &lt;th key={column}&gt;{column}&lt;/th&gt; ))} &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {data.map(({ name, email, phone }) =&gt; ( &lt;tr key={name + email + phone}&gt; &lt;td&gt;{name}&lt;/td&gt; &lt;td&gt;{email}&lt;/td&gt; &lt;td&gt;{phone}&lt;/td&gt; &lt;/tr&gt; ))} &lt;/tbody&gt; &lt;/table&gt; );}export default Table;React Table로 심화 테이블 만들기이제 본격적으로 React Table을 이용해서 테이블을 만들어볼게요. 다음과 같이 코드를 작성해 주세요.import React from \"react\";import { useTable } from \"react-table\";function Table({ columns, data }) { const { getTableProps, getTableBodyProps, headerGroups, rows, prepareRow, } = useTable({ columns, data }); return ( &lt;table {...getTableProps()}&gt; &lt;thead&gt; {headerGroups.map((headerGroup) =&gt; ( &lt;tr {...headerGroup.getHeaderGroupProps()}&gt; {headerGroup.headers.map((column) =&gt; ( &lt;th {...column.getHeaderProps()}&gt;{column.render(\"Header\")}&lt;/th&gt; ))} &lt;/tr&gt; ))} &lt;/thead&gt; &lt;tbody {...getTableBodyProps()}&gt; {rows.map(row =&gt; { prepareRow(row); return ( &lt;tr {...row.getRowProps()}&gt; {row.cells.map(cell =&gt; { return &lt;td {...cell.getCellProps()}&gt;{cell.render('Cell')}&lt;/td&gt; })} &lt;/tr&gt; ) })} &lt;/tbody&gt; &lt;/table&gt; );}와우, 이제 여러분도 실제 프로젝트에서 이를 활용해보세요! 😎🎉" }, { "title": "React Intl로 내 사이트 국제화하기", "url": "/posts/React-Intl%EB%A1%9C-%EB%82%B4-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EA%B5%AD%EC%A0%9C%ED%99%94%ED%95%98%EA%B8%B0/", "categories": "React", "tags": "Intl", "date": "2023-08-05 20:00:00 +0900", "snippet": "React Intl이란 무엇인가요? 🤷‍♀️React Intl은 npm을 통해 설치할 수 있답니다! 이 라이브러리를 사용하면 다국어 서비스를 아주 쉽게 만들 수 있습니다. 근데 다국어라니, 사람들이 왜 이걸 원할까요? 🤔 글로벌한 사이트에는 다양한 국적의 사람들이 들어오고 이 때 사람들의 국가에 맞춘 사이트를 표시한다면 이용하기가 편해지기 때문입니다.locale: 이게 뭐에요? 🌏locale이라는 건 간단히 말하자면 언어와 지역을 알려주는 고유 코드입니다. 한국어는 ko, 미국 영어는 en-US 같은 식으로요. 브라우저 설정에서 이 정보를 가져올 수 있고, localStorage에 저장해서 쓸 수도 있어요! 🍪const locale = navigator.language; // 또는 `navigator.languages[0]`// 또는const locale = localStorage.getItem(\"locale\") ?? \"ko\";메시지 관리는 어떻게 하나요? 💌메시지 관리는 JSON 파일을 사용해서 아주 깔끔하게 할 수 있어요! 📁 여러 언어를 지원하려면, 해당 언어별로 JSON 파일을 만들어주면 되는 것이죠!{ \"title\": \"리액트 Intl\", \"info\": \"현재 언어는 {locale}입니다.\", \"label\": \"언어\", \"button\": \"저장\"}이렇게 하면 여러 언어로 멋진 메시지를 뿌릴 수 있습니다! 🎉IntlProvider는 뭔가요? 🛡️&lt;IntlProvider/&gt;는 전역적으로 다국어 지원을 하기 위해 필요한 요소입니다. 최상위 컴포넌트를 이것으로 감싸주면, 모든 하위 컴포넌트에서도 다국어를 쉽게 처리할 수 있답니다! 😇function App() { return ( &lt;IntlProvider locale={locale} messages={messages}&gt; &lt;Page /&gt; &lt;/IntlProvider&gt; );}FormattedMessage로 다국어 메시지 출력하기 📣다국어 메시지 출력은 &lt;FormattedMessage/&gt; 컴포넌트로 아주 쉽게 할 수 있습니다. 이 컴포넌트에 id prop을 주면, 해당 메시지를 찾아서 보여줍니다!&lt;FormattedMessage id=\"title\" /&gt;마무리 🌈이렇게 React Intl을 활용하면 간편하고 쉽게 국제화가 가능합니다! 그럼 다음글에서 다시 만나요~ 🌟 🎉" }, { "title": "React Hook Form 로그인 폼 구현에서 더 나아가기", "url": "/posts/React-Hook-Form-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%8F%BC-%EA%B5%AC%ED%98%84%EC%97%90%EC%84%9C-%EB%8D%94-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0/", "categories": "React", "tags": "ReactHookForm", "date": "2023-08-04 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 React Hook Form 라이브러리로 로그인 폼을 만들면서 더 많은 것들을 배워볼 거에요. 말로만 듣던 로그인 폼, 드디어 직접 만들어보는 날이 왔습니다! 🎉설치부터 시작! 🚀먼저, 터미널을 열고 아래 명령어를 쳐주세요.$ npm install react-hook-form이제 라이브러리가 설치되었으니, 코드를 작성할 준비가 끝났습니다!JSX로 로그인 폼 만들기 🛠️아래는 기본적인 로그인 폼을 JSX로 어떻게 만드는지 보여주는 코드입니다.function LoginForm() { return ( &lt;form&gt; &lt;label htmlFor=\"email\"&gt;이메일&lt;/label&gt; &lt;input id=\"email\" type=\"email\" placeholder=\"test@email.com\" /&gt; &lt;label htmlFor=\"password\"&gt;비밀번호&lt;/label&gt; &lt;input id=\"password\" type=\"password\" placeholder=\"****************\" /&gt; &lt;button type=\"submit\"&gt;로그인&lt;/button&gt; &lt;/form&gt; );}export default LoginForm;별다를 것 없는 코드이죠? 그런데 여기서 시작입니다!React Hook Form 연동하기 🔄이제 React Hook Form을 이 로그인 폼과 연결해 봅시다! 아래 코드는 useForm() 훅을 사용해서 로그인 폼을 업그레이드하는 방법입니다.import { useForm } from \"react-hook-form\";function LoginForm() { const { register, handleSubmit } = useForm(); return ( &lt;form onSubmit={handleSubmit((data) =&gt; alert(JSON.stringify(data)))}&gt; &lt;label htmlFor=\"email\"&gt;이메일&lt;/label&gt; &lt;input id=\"email\" type=\"email\" placeholder=\"test@email.com\" {...register(\"email\")} /&gt; &lt;label htmlFor=\"password\"&gt;비밀번호&lt;/label&gt; &lt;input id=\"password\" type=\"password\" placeholder=\"****************\" {...register(\"password\")} /&gt; &lt;button type=\"submit\"&gt;로그인&lt;/button&gt; &lt;/form&gt; );}export default LoginForm;중복 제출? 이젠 안녕! 👋로그인 폼에서 중복으로 제출하는 문제를 해결해봅시다! 아래 코드에서 isSubmitting을 이용하여 버튼을 비활성화시켜 이 문제를 해결합니다.import { useForm } from \"react-hook-form\";function LoginForm() { const { register, handleSubmit, formState: { isSubmitting }, } = useForm(); return ( &lt;form onSubmit={handleSubmit(async (data) =&gt; { await new Promise((r) =&gt; setTimeout(r, 1000)); alert(JSON.stringify(data)); })} &gt; &lt;label htmlFor=\"email\"&gt;이메일&lt;/label&gt; &lt;input id=\"email\" type=\"email\" placeholder=\"test@email.com\" {...register(\"email\")} /&gt; &lt;label htmlFor=\"password\"&gt;비밀번호&lt;/label&gt; &lt;input id=\"password\" type=\"password\" placeholder=\"****************\" {...register(\"password\")} /&gt; &lt;button type=\"submit\" disabled={isSubmitting}&gt; 로그인 &lt;/button&gt; &lt;/form&gt; );}export default LoginForm;입력값 검증! 🛡️이메일과 비밀번호를 꼼꼼하게 검사해 봅시다. 아래 코드는 register() 함수에서 어떻게 입력값을 검증하는지를 보여줍니다.{ ...register(\"email\", { required: true, pattern: /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$/ })}{ ...register(\"password\", { required: true, minLength: 8 })}이제 이메일과 비밀번호를 잘못 입력하면 사용자에게 알려줍니다!나만의 로그인 폼, 완성! 🎊여러분, 이제 나만의 로그인 폼을 만들었습니다! 👏 React Hook Form 라이브러리를 이용해서 멋진 로그인 폼을 만들어 본 것이 어떠셨나요? 더 배우고 싶다면, 공식 문서도 잊지마세요! 📚" }, { "title": "MSW (Mock Service Worker)로 웹개발을 빠르게", "url": "/posts/MSW-(Mock-Service-Worker)%EB%A1%9C-%EC%9B%B9%EA%B0%9C%EB%B0%9C%EC%9D%84-%EB%B9%A0%EB%A5%B4%EA%B2%8C/", "categories": "React", "tags": "MSW", "date": "2023-08-02 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 😄 오늘은 신나는 주제로 찾아왔어요. 그 주제는 바로 MSW, 즉 Mock Service Worker에 관한 이야기입니다. 이것은 웹 개발을 한층 더 쉽고 재미있게 만들어주는 마법 같은 도구입니다!MSW가 뭐에요? 🤔MSW는 Mock Service Worker의 약자로, 웹 브라우저에게 가짜API를 제공합니다. 그리고 이 가짜 API는 우리가 작성한 프론트엔드 코드에 데이터를 넘겨줍니다. 진짜 API가 준비되기 전에 프론트엔드 개발을 빠르게 진행할 수 있게 해주는 것이죠.MSW의 놀라운 특징들 🌟실제 API와 다를 게 없어요!MSW의 가장 큰 장점은 네트워크 단에서 작동한다는 것입니다. 그래서 실제 API와 가짜 API를 교체하는 작업이 아주 쉽답니다. 그럼 이것은 뭐가 좋나요? 개발 생산성이 올라간다는 거죠! 🎉유연한 디자인 🤸‍♀️이 녀석은 굉장히 유연해요. 테스트 환경에서도, 브라우저에서도 동일한 요청 핸들러 코드를 공유해서 사용할 수 있습니다. 그러니까, 쓸모 있는 코드를 더 많이 작성할 수 있다는 거죠!다양한 API 모킹 지원 🌈REST API는 물론, GraphQL API도 모킹할 수 있어요!MSW 실습: To-Do 앱 만들기 🛠️실습으로 To-Do 앱을 만들어보려고 합니다. Create React App을 사용해서 간단하게 프로젝트를 생성할 거에요.$ npx create-react-app our-mswMSW 설치와 설정 🔧MSW 라이브러리를 설치합니다.$ npm install msw --save그 다음, MSW를 초기화합니다.$ npx msw init public/ --save요청 핸들러 작성 ✍️이제 가짜 API를 구현할 차례입니다! src/mocks/handlers.js라는 파일을 만들어서 핸들러 코드를 작성하겠습니다.// src/mocks/handlers.jsimport { rest } from \"msw\";export const handlers = [ rest.get(\"/todos\", (req, res, ctx) =&gt; { return res( ctx.json([ { id: 1, text: \"빨래하기\" }, { id: 2, text: \"코딩하기\" }, { id: 3, text: \"운동하기\" }, ]) ); }), rest.post(\"/todos\", (req, res, ctx) =&gt; { const newTodo = req.body; return res(ctx.json(newTodo)); }),];이제 할 일 목록을 불러오거나 새로운 할 일을 추가할 수 있을 거에요!마무리 🎉이렇게 해서 MSW를 활용한 웹 개발의 새로운 세계를 열어보았습니다! 이 도구를 활용하면 프론트엔드 개발이 훨씬 더 빠르고 재밌어질 거에요! 다음에 또 신나는 주제로 찾아올게요! 😄" }, { "title": "Emotion을 활용한 React 스타일링 마스터하기", "url": "/posts/Emotion%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-React-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81-%EB%A7%88%EC%8A%A4%ED%84%B0%ED%95%98%EA%B8%B0/", "categories": "React", "tags": "Emotion", "date": "2023-08-01 20:00:00 +0900", "snippet": "Emotion과 Styled Components, 무엇이 다른가요? 🤔Emotion과 Styled Components는 둘 다 CSS-in-JS라는 동일한 컨셉을 공유하고 있습니다. Emotion이 특별한 이유는 바로 성능과 확장성입니다! 🚀Emotion 설치하기 📦우선, Emotion을 설치하려면 터미널을 열고 다음 명령어를 입력하면 됩니다.npm install @emotion/react @emotion/styled단순하죠? 설치가 끝나면 이제 본격적으로 스타일링을 시작해 봅시다! 🎉Emotion 기초 문법 📚css() 함수의 매력 😍css() 함수는 Emotion의 핵심입니다. 🌟 이 함수를 이용하면 객체나 문자열 형태로 CSS 스타일을 적용할 수 있습니다.객체 형태로 스타일링하기/** @jsxImportSource @emotion/react */import { css } from '@emotion/react'function MyComponent() { return ( &lt;div css={css({ backgroundColor: 'yellow' })}&gt; 노란색 배경 &lt;/div&gt; )}문자 형태로 스타일링하기/** @jsxImportSource @emotion/react */import { css } from '@emotion/react'function MyComponent() { return ( &lt;div css={css`background-color: yellow;`}&gt; 노란색 배경 &lt;/div&gt; )}JSX Pragma는 뭐에요? 🤷‍♀️JSX Pragma는 Emotion의 jsx() 함수를 사용하도록 알려주는 신호입니다./** @jsxImportSource @emotion/react */이 신호를 빼먹으면 스타일이 제대로 반영되지 않아요. 주의, 주의! 🚨실전! 버튼 컴포넌트 만들기 🎮예제 코드 📝/** @jsxImportSource @emotion/react */function Button({ children }) { return ( &lt;button css= &gt; {children} &lt;/button&gt; )}이렇게 코드 몇 줄로 멋진 버튼을 만들어 냈습니다! 😎결론 🎉이상으로 Emotion을 활용한 React 스타일링의 세계를 함께 탐험한 것을 마무리하겠습니다. 이제 여러분도 스타일링 마스터가 되어 볼 시간입니다! 🎓 감사합니다! 다음에 또 만나요! 🙌" }, { "title": "이미지를 배경으로 화려하게 스타일링하기", "url": "/posts/%EC%9D%B4%EB%AF%B8%EC%A7%80%EB%A5%BC-%EB%B0%B0%EA%B2%BD%EC%9C%BC%EB%A1%9C-%ED%99%94%EB%A0%A4%ED%95%98%EA%B2%8C-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81%ED%95%98%EA%B8%B0/", "categories": "CSS", "tags": "이미지를배경으로", "date": "2023-07-14 20:00:00 +0900", "snippet": "들어가기 전에, 왜 이 글을 읽어야 하나요?SVG는 웹 디자인에서 빠질 수 없는 중요한 요소입니다. SVG는 ‘Scalable Vector Graphics’의 약자로, 확대나 축소를 해도 깨지지 않는 그림을 말하는데요! 오늘은 이런 멋진 SVG를 CSS로 어떻게 배경 이미지로 쓸 수 있는지 알아보겠습니다!실습 준비물 🎒우리는 HTML에서 &lt;div&gt; 태그를 세 개 만들어 볼 거에요. 두 번째와 세 번째 &lt;div&gt;에는 각각 ‘check’와 ‘heart’라는 클래스를 붙여 줍니다.&lt;div&gt;TEXT&lt;/div&gt;&lt;div class=\"check\"&gt;CHECK&lt;/div&gt;&lt;div class=\"heart\"&gt;HEART&lt;/div&gt;CSS에서는 텍스트 크기와 배경색을 설정해 줍니다. SVG 이미지가 들어갈 자리도 넉넉하게 마련해 주세요!div { font-size: 3rem; padding-left: 4rem; margin: 1rem; background-color: ghostwhite;}배경으로 깔리는 SVG의 모습은? 🖼️check와 heart 클래스에 스타일을 추가해서, 각각 체크 모양과 하트 모양의 SVG 이미지가 뜨게 해볼 거에요.원격에서 SVG 가져오기CSS에서 배경 이미지를 설정할 때는 background-image 속성을 써요. SVG 이미지도 마찬가지입니다!.check { background-image: url(\"https://s2.svgbox.net/octicons.svg?ic=check\"); background-repeat: no-repeat; background-position: center left; background-size: contain;}.heart { background-image: url(\"https://s2.svgbox.net/hero-solid.svg?ic=heart\"); background-repeat: no-repeat; background-position: center left; background-size: contain;}Data URI로 더 똑똑하게 로딩 🤓원격에서 이미지를 불러오는 것보다 더 똑똑한 방법이 있어요! 바로 Data URI를 사용하는 것입니다. 이렇게 하면 웹 페이지 로딩 속도가 훨씬 빨라져요!.check { background-image: url('data:image/svg+xml;utf8,&lt;svg ... &gt;'); /* ... */}.heart { background-image: url('data:image/svg+xml;utf8,&lt;svg ... &gt;'); /* ... */}색을 바꾸고 싶다면? 🍯SVG 이미지 색상을 바꿔 보고 싶다면 어떻게 하나요? mask-image 속성을 사용해보세요!.check::before { /* ... */ mask-image: url(\"https://s2.svgbox.net/octicons.svg?ic=check\"); /* ... */}.heart::before { /* ... */ mask-image: url(\"https://s2.svgbox.net/hero-solid.svg?ic=heart\"); /* ... */}정리하면서 📝SVG 배경을 사용하면 웹 사이트가 더 멋지고 기능적으로도 탁월해질 거에요! 이상으로 이번 글을 마치겠습니다. 함께해 주셔서 감사합니다! 다음에 또 만나요! 👋🎈" }, { "title": "TailwindCSS 웹 개발을 더욱 즐겁게", "url": "/posts/TailwindCSS-%EC%9B%B9-%EA%B0%9C%EB%B0%9C%EC%9D%84-%EB%8D%94%EC%9A%B1-%EC%A6%90%EA%B2%81%EA%B2%8C/", "categories": "CSS", "tags": "TailwindCSS", "date": "2023-07-12 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 이번에는 굉장히 핫한 친구, 바로 Tailwind CSS에 대해 풀어보려고 합니다. 대체 이 녀석이 뭐길래 개발자 사이에서 화제인지, 함께 알아봅시다!왜 Tailwind CSS가 대박인가요? 🌟일단 Tailwind CSS는 유틸리티 클래스 기반 입니다. 유틸리티 클래스라는 것은 특정 스타일을 정의해 놓은 작은 조각들이에요. 이 작은 조각들을 조합해서 웹페이지를 예쁘게 꾸미는 거죠. “유틸리티 클래스는 마치 레고 블럭 같아요! 레고 블럭을 어떻게 조립하느냐에 따라, 성을 만들 수도, 자동차를 만들 수도 있죠. 👷‍♀️”Tailwind는 HTML의 친한친구 🦸‍♂️Tailwind를 사용한다면 HTML만으로도 웹페이지를 꾸밀 수 있어요! CSS 파일에 코드를 추가하지 않아도 됩니다. HTML의 class 속성에다 Tailwind의 유틸리티 클래스 이름을 적어주면 끝이거든요.예를 들어, 파란색 버튼을 만들고 싶다면?&lt;button class=\"bg-blue-500 text-white\"&gt;파란 버튼&lt;/button&gt;이렇게 하면 됩니다! 간단하죠? 🎉Tailwind CSS의 유틸리티 클래스 예시 🎨아래는 몇 가지 유틸리티 클래스 예시입니다. .text-white: 글자를 하얀색으로 만들어요. .bg-blue-500: 배경을 파란색으로 바꿉니다. .px-4: 양 옆에 패딩을 추가해요.Mermaid 다이어그램으로 Tailwind 이해하기 🧜‍♀️graph TD; A[HTML] --&gt; B[Tailwind CSS]; B --&gt; C[유틸리티 클래스]; C --&gt; D{예쁜 웹페이지!};이 다이어그램을 보면, HTML과 Tailwind CSS가 어떻게 연결되는지 쉽게 이해할 수 있어요. 여러분도 이런 식으로 웹페이지를 쉽고 빠르게 만들어보세요!Tailwind의 장단점 🎭장점 ✅ 빠른 개발: 코드를 줄일 수 있어서 빠르게 개발할 수 있어요. 쉬운 유지보수: 클래스만 변경하면 되니까 유지보수가 쉽습니다.단점 ❌ 익숙해지는 데 시간이 좀 필요해요. 프로젝트가 커지면 클래스 이름이 너무 많아져서 복잡해질 수 있어요.결론: Tailwind CSS, 꼭 써보세요! 🎁메인 프로젝트라면 도입이 꺼려질 수 있지만 사이드 프로젝트 및 취미 목적이라면 뭐하러 다른 걸 쓰고 고생하나요? Tailwind CSS로 쉽고 빠르게 웹 개발을 즐겨보세요! 이제 여러분도 Tailwind 마스터로 거듭나보아요! 🚀" }, { "title": "React 체크박스 더이상 복잡하게 생각하지 마세요", "url": "/posts/React-%EC%B2%B4%ED%81%AC%EB%B0%95%EC%8A%A4-%EB%8D%94%EC%9D%B4%EC%83%81-%EB%B3%B5%EC%9E%A1%ED%95%98%EA%B2%8C-%EC%83%9D%EA%B0%81%ED%95%98%EC%A7%80-%EB%A7%88%EC%84%B8%EC%9A%94/", "categories": "CSS", "tags": "React체크박스", "date": "2023-07-11 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 아주 재미있는 이야기로 찾아왔습니다. 바로 React 체크박스를 어떻게 만들고 관리하는지에 대한 미스터리를 풀어보려고 해요! 🕵️‍♂️ 준비됐나요? 그럼 가보자구~ 🚀체크박스를 왜 쓸까요? 🤔그러게요, 왜 쓸까요? 아주 간단합니다. 체크박스는 사용자로부터 ‘예’ 또는 ‘아니요’ 같은 간단한 응답을 받을 수 있는 최고의 방법입니다. 이는 특히 회원 가입 페이지나 설문조사 같은 곳에서 유용하죠!체크박스 기초 설계 🏗️function Checkbox({ children, disabled, checked, onChange }) { return ( &lt;label&gt; &lt;input type=\"checkbox\" disabled={disabled} checked={checked} onChange={({ target: { checked } }) =&gt; onChange(checked)} /&gt; {children} &lt;/label&gt; );}여기서 children은 라벨의 이름이고, disabled는 체크박스를 사용할 수 없게 할지 결정하는 옵션입니다. checked는 체크박스가 선택되어 있는지 아닌지를 나타내고, onChange는 체크박스의 상태가 바뀔 때 불리는 함수입니다.체크박스의 실전 활용 🥷import React from \"react\";import Checkbox from \"./Checkbox\";function App() { const [service, setService] = React.useState(false); const [marketing, setMarketing] = React.useState(false); return ( &lt;article&gt; &lt;header&gt; &lt;h3&gt;체크박스&lt;/h3&gt; &lt;/header&gt; &lt;Checkbox checked={service} onChange={setService}&gt; (필수) 서비스 이용약관 &lt;/Checkbox&gt; &lt;Checkbox checked={marketing} onChange={setMarketing}&gt; (선택) 마케팅 수신 &lt;/Checkbox&gt; &lt;footer&gt; &lt;button disabled={!service}&gt;회원 가입&lt;/button&gt; &lt;/footer&gt; &lt;/article&gt; );}여기서 useState는 React에서 상태를 관리하기 위해 사용하는 훅(hook)입니다. 이를 통해 service와 marketing 상태를 관리하고 있어요.체크박스의 마법 같은 연결 🪄아무래도 여러 체크박스가 동시에 쓰일 경우가 많죠. 이럴 때는 CheckboxContext를 사용해서 정보를 공유합니다. React의 createContext 함수로 만들 수 있어요.import { createContext } from \"react\";const CheckboxContext = createContext();체크박스 그룹을 만들어보자! 👨‍👩‍👦‍👦이제 여러 체크박스를 묶어서 관리하는 CheckboxGroup 컴포넌트를 만들어 볼까요?graph TD; A[CheckboxGroup] --&gt; B[CheckboxContext.Provider] B --&gt; C[Checkbox1] B --&gt; D[Checkbox2] B --&gt; E[Checkbox3]코드는 이렇게 생겼습니다!import CheckboxContext from \"./CheckboxContext\";function CheckboxGroup({ label, children, disabled: groupDisabled, values, onChange }) { // 함수들... return ( &lt;fieldset&gt; &lt;legend&gt;{label}&lt;/legend&gt; &lt;CheckboxContext.Provider value=&gt; {children} &lt;/CheckboxContext.Provider&gt; &lt;/fieldset&gt; );}이런 식으로 체크박스가 많을 때도 아주 쉽게 관리할 수 있답니다! 😎와우, 끝났어요! 이제 여러분도 체크박스 사용법에 대해 대략적인 이해가 되셨죠? 🥳 만약 더 궁금한 점이 있으면 언제든 댓글로 물어봐 주세요~ 다음에 또 새로운 이야기로 찾아올게요. 그럼 안녕! 👋😄" }, { "title": "Play CDN을 활용해 TailwindCSS를 더 쉽게", "url": "/posts/Play-CDN%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%B4-TailwindCSS%EB%A5%BC-%EB%8D%94-%EC%89%BD%EA%B2%8C/", "categories": "CSS", "tags": "TailwindCSS", "date": "2023-07-10 20:00:00 +0900", "snippet": "TailwindCSS를 간단하게! Play CDN 소개 🎉안녕하세요! 🎊 오늘은 대세 프론트엔드 프레임워크 TailwindCSS를 아주 쉽게 사용할 수 있는 방법, 바로 Play CDN에 대해 소개해 드릴게요.Play CDN은 뭐고 왜 필요한가요? 🤔Play CDN은 TailwindCSS를 사용하고 싶지만, 설정 과정이 귀찮은 분들이나 초기 세팅에서 좀 막막해지시는 분들을 위한 최고의 솔루션이에요.🤩 이제 복잡한 설정 파일 만지작거리는 일은 그만! HTML 문서 안에서 &lt;script&gt; 태그 한 줄로 TailwindCSS를 사용할 수 있답니다!&lt;head&gt; &lt;script src=\"https://cdn.tailwindcss.com\"&gt;&lt;/script&gt;&lt;/head&gt;잠깐만, 추가로 플러그인도 사용하고 싶다고요? 🤩네, 그럼 쿼리 문자열을 이용해 plugins 파라미터를 명시하면 돼요! 이렇게요:&lt;head&gt; &lt;script src=\"https://cdn.tailwindcss.com?plugins=forms,typography\"&gt;&lt;/script&gt;&lt;/head&gt;꿀팁! 전역 설정은 어떻게 하나요? 🍯이것도 쉬워요! 전역 속성에 설정 객체를 할당해주기만 하면 끝! 이렇게 해볼까요?&lt;head&gt; &lt;script src=\"https://cdn.tailwindcss.com\"&gt;&lt;/script&gt; &lt;script&gt; tailwind.config = { theme: { extend: { colors: { tomato: \"tomato\", }, }, }, }; &lt;/script&gt;&lt;/head&gt;추가 CSS 클래스가 필요하면? 🤔이 부분도 너무 쉬워요. &lt;style&gt; 요소의 type 속성을 text/tailwindcss로 설정한 다음, @layer 지시문을 사용해 클래스를 추가하면 끝!&lt;head&gt; &lt;style type=\"text/tailwindcss\"&gt; @layer components { .btn { @apply rounded bg-blue-500 px-4 py-2 font-bold text-white hover:bg-blue-600; } } &lt;/style&gt;&lt;/head&gt;실습으로 배워보자! 👩‍💻👨‍💻그런데 이것보다 더 쉬운 방법이 있어요! 바로 Tailwind Play라는 온라인 에디터를 사용하는 거에요. 설치 필요없이 간단하게 웹에서 테스트 해 볼 수 있답니다. TailwindCSS를 사용하는 데 복잡한 설정은 이제 안녕!😎" }, { "title": "HTML과 CSS로 스위치 UI 만들기", "url": "/posts/HTML%EA%B3%BC-CSS%EB%A1%9C-%EC%8A%A4%EC%9C%84%EC%B9%98-UI-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "CSS", "tags": "스위치UI", "date": "2023-07-09 20:00:00 +0900", "snippet": "안녕하세요, 웹 개발자 여러분! 🤗 오늘은 웹사이트에서 눈에 띄는 스위치 UI를 만들어보려고 해요. 토글 스위치라고 부르는 이 친구, 왜 필요한지 모르겠다고요? 지금부터 아래를 잘 읽어보세요!토글 스위치란 무엇인가요? 🤔우리 집의 불도 켜고 끄고 할 수 있어야 하듯이, 웹에서도 사용자가 어떤 기능을 켜거나 끌 수 있어야 해요. 토글 스위치는 바로 그런 역할을 해주는 요소입니다. 이제부터 친구로 불러볼게요. 친구야, 나와라~!HTML 체크박스를 스위치로 활용 🎉네, 여러분이 생각한 것처럼, HTML의 체크박스는 우리 친구 스위치의 원형이에요. 왜? 기능이 비슷하니까요!&lt;label&gt; &lt;input role=\"switch\" type=\"checkbox\" /&gt; &lt;span&gt;알람 켜기&lt;/span&gt;&lt;/label&gt;위 코드는 HTML 체크박스를 사용하여 스위치를 만드는 가장 간단한 예입니다. 이제부터 이 친구를 멋지게 꾸며볼까요?스타일링 작업 시작! 👗기본 스타일 제거먼저, 체크박스의 기본 스타일을 지워버려야 해요.[type=\"checkbox\"] { appearance: none;}와~ 이제 체크박스가 보이지 않아요! 신기방기, 마술처럼 사라진 건 아니에요, 크기가 그냥 0으로 줄어든 거죠. 😂알약 스타일체크박스를 알약처럼 만들어 볼게요. 아래와 같이 코드를 작성해주세요.[type=\"checkbox\"] { appearance: none; position: relative; border: max(2px, 0.1em) solid gray; border-radius: 1.25em; width: 2.25em; height: 1.25em;}엄지 스타일 🤙이제 엄지 스타일을 적용해 볼게요.[type=\"checkbox\"]::before { content: \"\"; border-radius: 50%; /*...*/}여기서 ::before는 가상 요소입니다. 뭐라고요? 가상 요소란 실제 DOM에는 없지만, 스타일링을 위해 존재하는 요소랍니다!마무리 🎉그럼 여기서 마무리할게요, 여러분! 이제 웹 페이지에서 멋진 토글 스위치를 만들어보세요. 행복한 코딩 되세요! 😄" }, { "title": "HTML 리스트 ul, ol, li 제대로 쓰는법", "url": "/posts/HTML-%EB%A6%AC%EC%8A%A4%ED%8A%B8-ul,-ol,-li-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%93%B0%EB%8A%94%EB%B2%95/", "categories": "CSS", "tags": "HTML리스트", "date": "2023-07-08 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 리스트는 웹 페이지에서 꼭 필요한 친구죠. 오늘은 &lt;ul&gt;, &lt;ol&gt;, &lt;li&gt; 같은 HTML 리스트 요소를 어떻게 멋지게 꾸밀 수 있는지 알려드릴게요! 😎내장 스타일이 뭐에요? 🤔브라우저에 이미 내장된 스타일이 있어요. 이걸 user agent stylesheet라고 부르는데요, 이게 뭐냐면 브라우저가 자동으로 준 스타일입니다! 잠깐 볼까요?ul { display: block; list-style-type: disc; padding-inline-start: 40px;}ol { display: block; list-style-type: decimal; padding-inline-start: 40px;}브라우저가 얼마나 친절한지 보세요! 이미 기본적인 것들은 셋팅해 놓았어요. 😊리스트 레이아웃은 어떻게 바꾸죠? 🛠간격 조절하기아이템 간에 더 많은 공간을 주려면 line-height를 사용해보세요!ul, ol { line-height: 1.8;}들여쓰기 줄이기40px은 너무 많다고요? padding-inline-start로 줄여보세요!ul, ol { padding-inline-start: 20px;}헐! 외부 공백도 없애줘!margin을 0으로 설정하면 외부 공백도 없어져요.ul, ol { margin: 0;}마커는 어떻게 바꿀까요? ✨마커 위치 옮기기마커를 리스트 안으로 옮기려면 list-style-position을 inside로 바꾸세요!ul, ol { list-style-position: inside;}마커 모양 바꾸기사각형으로 바꾸려면 이렇게 해보세요!ul { list-style-type: square;}ol { list-style-type: upper-alpha;}이미지 마커 사용하기 🖼이미지로 마커를 설정하려면 list-style-image를 사용하세요!ul { list-style-image: url('your-image-url');}마무리 🧜‍♀️어떤가요? 이제 &lt;ul&gt;, &lt;ol&gt;, &lt;li&gt; 요소가 더 이상 무서워 보이지 않죠? 🎉🎉 재미있게 코딩하시길 바라요! 😄graph TD; A[ul, ol, li] --&gt; B[브라우저 내장 스타일링] A --&gt; C[리스트 레이아웃 조정] A --&gt; D[마커 위치와 모양 바꾸기]" }, { "title": "CSS의 height와 min-height", "url": "/posts/CSS%EC%9D%98-height%EC%99%80-min-height/", "categories": "CSS", "tags": "min-height", "date": "2023-07-07 20:00:00 +0900", "snippet": "안녕하세요, 오늘 다룰 주제는 바로 CSS에서의 height 속성과 min-height 속성! “높이? 그게 뭐 중요하다고?”라고 생각할 수도 있지만, 높이를 잘못 설정하면 웹페이지가 엉망이 될 수 있어요. 😱 그럼 본격적으로 시작해 봅시다!높이는 왜 중요한가요? 🤔웹 페이지는 상자(box)로 이루어져 있습니다. 이 상자의 높이를 잘 설정해야 내부의 텍스트나 이미지가 제대로 보이거든요. 그래서 height 속성을 사용하는 것이죠. 하지만, 여기서 조심해야 할 함정이 있습니다!🚫 height의 위험성height를 직접 설정하면, 상자가 너무 작아져서 내용물이 밖으로 튀어나올 수 있어요. 이런 현상을 ‘오버플로우(overflow)’라고 합니다. 특히 모바일에서는 이런 문제가 더 자주 발생해요.🎉 해결책: min-height 속성이럴 때 사용하는 게 min-height 속성입니다. 이 속성을 사용하면, 상자의 높이가 너무 작아지지 않아요. 내용물이 많으면 상자의 높이가 자동으로 늘어나고, 내용물이 적으면 설정한 높이를 유지합니다. 완전 편리하죠?graph TD; A[height 사용] --&gt;|오버플로우 위험| B[문제 발생] A --&gt;|min-height 사용| C[안전한 레이아웃]min-height의 활용법 🛠️min-height를 사용할 때는 단위도 중요해요. 픽셀(px), 퍼센트(%) 등 여러 단위가 있지만, 반응형 웹 디자인을 생각한다면 퍼센트가 더 유용할 때도 있습니다. 이러한 단위 선택은 상황에 따라 달라져요. 따라서, 여러 경우를 시험해 보는 것이 중요합니다.마무리 🎁오늘은 CSS의 height와 min-height에 대해 알아보았습니다. 이 두 속성을 잘 활용하면 웹페이지 레이아웃을 더 안정적으로 만들 수 있어요. 기억하세요, 높이 설정은 작은 것 같지만 큰 영향을 미친다는 것을요! 😄그럼 다음에 또 만나요! 행복한 코딩 되세요! 🎉👋" }, { "title": "CSS에서 White-Space 속성으로 공백 제어하기", "url": "/posts/CSS%EC%97%90%EC%84%9C-White-Space-%EC%86%8D%EC%84%B1%EC%9C%BC%EB%A1%9C-%EA%B3%B5%EB%B0%B1-%EC%A0%9C%EC%96%B4%ED%95%98%EA%B8%B0/", "categories": "CSS", "tags": "White-Space", "date": "2023-07-06 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 누구나 한 번쯤 겪어보는, 그렇지만 무시하기 쉬운 CSS의 white-space 속성에 대해 알려드릴게요. 이 글을 읽고 나면, 더는 공백 때문에 고생하지 않을 거에요! 😎이게 뭐야? CSS의 마법사, White-Space! 🧙‍♂️공백은 정말 짜증나죠. HTML에서 스페이스를 열 번 눌러도, 그게 웹 페이지에서는 하나로 보여지는 경우가 많아요. 이럴 때 쓰는 것이 바로 white-space 속성입니다! 이게 진짜 마법사 같아요. 공백 문자를 어떻게 처리할지 정해주는 놀라운 속성이죠.Normal 설정은 어떻게 동작해? 🤔white-space의 기본 설정은 normal입니다. 이 설정에서는 연속된 띄어쓰기나 줄바꿈이 모두 무시되어 버려요. 뿐만 아니라, 긴 텍스트는 자동으로 줄바꿈 됩니다. 이럴 때 원하는 위치에서 줄바꿈을 하려면 어떻게 해야 할까요?NoWrap 설정으로 해결해보자 🤫nowrap 설정은 줄바꿈을 일으키지 않습니다. 이 설정은 그 외에는 normal과 동일하게 작동해요. 따라서 연속된 띄어쓰기, 들여쓰기, 줄바꿈 문자는 모두 무시하고 하나로 처리합니다. 텍스트가 부모 요소 밖으로 나가면 어떻게 할까요? overflow 속성을 hidden으로 설정하면 됩니다. 이렇게 하면 숨겨진 텍스트가 보이지 않게 되어요!Pre 설정으로 공백 문자 미리보기! 🤩pre 설정은 텍스트에 포함된 모든 공백 문자를 그대로 표시해줍니다. 특히 코드를 웹 페이지에 그대로 보여주고 싶을 때 유용해요. 들여쓰기, 줄바꿈, 띄어쓰기를 모두 유지할 수 있어요! 🎉와우! 이제 white-space에 대해 알았으니, 실제로 활용해보세요! 🌟 다음에 또 뵙겠습니다! 🖐 더 좋은 블로그를 위해서 항상 노력하겠습니다! 😊" }, { "title": "CSS 이미지 아래에 생기는 공백, 쉽게 없애보자", "url": "/posts/CSS-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%95%84%EB%9E%98%EC%97%90-%EC%83%9D%EA%B8%B0%EB%8A%94-%EA%B3%B5%EB%B0%B1,-%EC%89%BD%EA%B2%8C-%EC%97%86%EC%95%A0%EB%B3%B4%EC%9E%90/", "categories": "CSS", "tags": "이미지공백", "date": "2023-07-05 20:00:00 +0900", "snippet": "이미지 아래에 생기는 공백, 왜 그러지? 🤔웹 개발을 하다 “왜 이미지 아래에 공백이 생기지?” 하고 고민한 적 있으신가요? 오늘은 그 이유와 해결책을 알아보는 시간을 가져보려고 합니다.&lt;img&gt; 요소를 &lt;div&gt;나 &lt;figure&gt;와 같은 부모 요소 안에 넣을 때 생기는 공백! 이 친구는 원래 &lt;img&gt;의 성격에 따라 생기는 거에요. &lt;img&gt;는 텍스트처럼 나란히 배치되는 인라인(inline) 요소이기 때문입니다. 그래서 텍스트의 라인을 맞추기 위한 가상의 가로선, 베이스라인(baseline)이라는 친구가 있죠.1. vertical-align으로 척척 해결! ✌️최고의 해결책은 vertical-align 속성을 사용하는 것! 이를 통해 이미지의 상하 정렬 기준을 바꿀 수 있어요.img { vertical-align: bottom;}이렇게 하면 이미지 아래의 공백은 사라집니다. 베이스라인의 문제가 해결되는 거죠!2. display 속성으로 깔끔하게! 🌟두 번째 방법은 &lt;img&gt; 요소의 display 속성을 block으로 바꾸는 것이에요.img { display: block;}이렇게 하면 이미지가 블록(block) 요소가 되어 문제가 해결됩니다. 하지만 여러 이미지가 좌우로 나열되지 않고 상하로 배치되는 부분을 주의하셔야 해요!3. 부모 요소의 line-height를 조정! 👨‍👧‍👦만약 직접 스타일을 줄 수 없다면, 부모 요소의 line-height를 0으로 설정하면 됩니다.div { line-height: 0;}이렇게 하면 문제가 해결되고, 아주 깔끔하게 이미지가 배치됩니다. 🎉이미지 사이에 생기는 공백도 신경써야 해! 🤨여러 이미지를 나열할 때 생기는 공백도 문제죠. 이런 공백은 &lt;img&gt; 태그 사이의 띄어쓰기나 줄바꿈 때문에 생깁니다.&lt;div&gt; &lt;img src=\"https://via.placeholder.com/200\" alt=\"placeholder\" /&gt;&lt;img src=\"https://via.placeholder.com/200\" alt=\"placeholder\" /&gt;&lt;img src=\"https://via.placeholder.com/200\" alt=\"placeholder\" /&gt;&lt;/div&gt;그래서 태그 사이에 띄어쓰기나 줄바꿈 없이 태그를 붙이면 해결 가능합니다. 아주 쉽죠? 😆정리하면 🌈이렇게 웹 페이지의 이미지 공백 문제를 해결하는 방법은 여러가지가 있죠. 어떤 방법을 선택할지는 여러분의 상황과 필요에 따라 다르겠지만, 이번에 소개한 방법들로 대부분의 문제는 해결할 수 있을 거예요. 다들 화이팅! 🎉✨" }, { "title": "CSS 영어와 한국어의 줄바꿈 차이와 해결법", "url": "/posts/CSS-%EC%98%81%EC%96%B4%EC%99%80-%ED%95%9C%EA%B5%AD%EC%96%B4%EC%9D%98-%EC%A4%84%EB%B0%94%EA%BF%88-%EC%B0%A8%EC%9D%B4%EC%99%80-%ED%95%B4%EA%B2%B0%EB%B2%95/", "categories": "CSS", "tags": "CSS줄바꿈", "date": "2023-07-04 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 이번엔 “영어와 한국어의 줄바꿈 차이와 그 해결법”에 대해 이야기해 봅시다!영어는 왜 줄바꿈이 자동으로 안될까? 🎉프로그래밍을 하다보면 한글은 줄을 잘 바꾸는데, 영어는 왜 그렇게 부모 요소를 넘어가는 걸까요? 한글은 단어의 중간에서도 줄바꿈을 하는게 기본 속성인 반면, 영어는 그렇지 않기 때문입니다.overflow-wrap: 실질적인 해결사 🦸‍♀️CSS의 overflow-wrap 속성은 이 문제를 해결해 줄 수 있어요. 이걸 break-word로 설정하면, 부모 요소 안에서 단어가 넘치지 않게 됩니다..example { overflow-wrap: break-word;}이제는 단어별로 줄바꿈이 되는걸 확인할 수 있어요!hyphens 속성으로 자동 줄바꿈 🌈hyphens 속성을 auto로 설정하면, 자동으로 줄바꿈을 해 줍니다. 단어가 삐져나가려고 할 때, 마법처럼 - 기호가 나타나요!.example { hyphens: auto;}이렇게 하면 단어가 더 이상 삐져나가지 않고, 모든 브라우저에서 멋지게 보이게 됩니다!📊 다이어그램을 통한 이해graph TD; A[줄바꿈 문제] A --&gt;|해결방법1| D[overflow-wrap] A --&gt;|해결방법2| E[hyphens]이 다이어그램을 통해 여러분은 줄바꿈 문제를 어떻게 해결할 수 있는지 한 눈에 알 수 있을 겁니다!마치며 🌟웹 개발을 하다 보면 우리는 때때로 문제 해결의 달인이 되어야 해요. overflow-wrap, hyphens 같은 해결책을 알고 있으면 더 이상 단어가 삐져나가는 건 두렵지 않겠죠? 😎 그럼 오늘도 즐거운 코딩 되세요! 🌈👩‍💻👨‍💻" }, { "title": "CSS z-index 그렇게 쓰지 마세요", "url": "/posts/CSS-z-index-%EA%B7%B8%EB%A0%87%EA%B2%8C-%EC%93%B0%EC%A7%80-%EB%A7%88%EC%84%B8%EC%9A%94/", "categories": "CSS", "tags": "z-index", "date": "2023-07-03 20:00:00 +0900", "snippet": "안녕하세요, 웹 개발자 여러분! 오늘은 3차원 세계에 발을 들여보겠습니다. 어떻게요, 궁금하지 않나요? 네, 오늘의 주인공은 바로 CSS의 z-index 속성입니다! 🌟z-index 없을 때먼저, z-index가 없으면, HTML 문서에서 나중에 나온 요소가 먼저 나온 요소를 따라잡아요! 🏃‍♀️&lt;div class=\"first box\"&gt;1&lt;/div&gt;&lt;div class=\"second box\"&gt;2&lt;/div&gt;.first.box { background: yellow;}.second.box { background: tomato; margin-top: -50px; margin-left: 50px;}위와 같이 코드를 작성하면, 두 번째 박스가 첫 번째 박스를 아주 쉽게 따라잡습니다.Position 속성이 등장하면?하지만 여기에 position 속성이 등장하면 일이 꼬이기 시작해요. position이 relative나 absolute, fixed, sticky로 바뀌면 겹치는 순서도 바뀌죠..first.box { background: yellow; position: relative; top: 50px; left: 50px;}이렇게 하면, 첫 번째 상자가 두 번째 상자 위로 다시 등장합니다.z-index의 등장! 🎬이제 본격적으로 z-index가 등장합니다..first.box { z-index: 1; background: yellow; position: relative; top: 50px; left: 50px;}.second.box { z-index: 2; background: tomato; position: relative;}이렇게 하면 두 번째 상자가 첫 번째 상자를 다시 앞질러서 나오게 됩니다. 이럴 때 사용되는 용어가 바로 z-index입니다. 상자 뒤에 숫자를 크게 적으면 앞으로 나오게 되고, 작게 적으면 뒤로 가게 됩니다.주의사항 🚨position이 static인 요소에는 z-index가 무용지물이에요. position을 absolute, relative, fixed, sticky로 변경하면서 z-index를 사용해야 효과가 나타납니다.graph TD; A[position: static] --&gt; B[z-index 안먹힘]; C[position: absolute, relative, fixed, sticky] --&gt; D[z-index 먹힘];정리하면 z-index와 position 함께 사용해야 진정한 효과를 발휘한다고 생각하면 됩니다. 👫 오늘은 z-index 사용법을 탐구해봤습니다. 함께해주신 여러분, 정말 수고하셨습니다! 🎉💕" }, { "title": "CSS Reset과 CSS Normalize", "url": "/posts/CSS-Reset%EA%B3%BC-CSS-Normalize/", "categories": "CSS", "tags": "Reset, Normalize", "date": "2023-07-02 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 이 세상에는 수많은 브라우저들이 존재합니다. 크롬부터 사파리, 파이어폭스까지! 아마도 여러분의 웹페이지가 어떤 브라우저에서 잘 돌아갈지 예측하는 건 마치 로또 번호 맞추기와 같죠. 😆 하지만 걱정 마세요! 오늘 우리는 CSS Reset과 CSS Normalize라는 두 명의 슈퍼히어로를 소개할 것입니다.CSS Reset: 깔끔한 시작을 위한 브라우저 통일작전 🧹브라우저가 자체적으로 HTML 요소에 적용한 스타일이 있다면, CSS Reset은 그것을 “제로(Zero)”로 만들어줍니다. 즉, 웹페이지의 모든 것을 깨끗하게 초기화시켜준다는 뜻이에요. 예를 들어, 아래와 같이 CSS 코드를 작성하면 모든 HTML 요소의 스타일을 초기화할 수 있습니다.html, body, div, span, ... { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;}이렇게 하면, 웹페이지의 모든 요소가 동일한 모습으로 보이게 됩니다. 본래의 브라우저 스타일이 사라져버리니, 여러분이 원하는 스타일을 적용하기가 훨씬 수월해진답니다!CSS Normalize: 브라우저 차이 최소화 🌈CSS Normalize는 브라우저 간 차이를 최소화하면서, 브라우저가 제공하는 기본 스타일을 최대한 활용합니다. 예를 들어, 아래와 같이 코드를 작성하면 특정 브라우저에서만 발생하는 문제를 해결할 수 있어요.h1 { font-size: 2em; margin: 0.67em 0;}a { background-color: transparent;}여기서 CSS Normalize의 장점은 브라우저별로 미세하게 다른 부분만 통일시켜주기 때문에, 기본적인 사용성을 해치지 않는다는 점입니다.어떤 걸 선택할까요? 🤔CSS Reset은 모든 것을 깨끗하게 지워버리는 “깨끗이 정화” 스타일이고, CSS Normalize는 필요한 부분만 수정하는 “선택적 정화” 스타일입니다. 선택은 여러분의 목표와 필요에 따라 달라질 수 있어요.🧜‍♂️ Reset과 Normalize 비교graph TD; A[CSS Reset] --&gt;|깨끗한 초기화| B[브라우저 통일]; C[CSS Normalize] --&gt;|선택적 정화| D[브라우저 차이 최소화];어때요, 어렵지 않죠? 😆 이제 브라우저 문제로 머리를 싸매지 않아도 되겠어요. CSS Reset과 CSS Normalize, 두 슈퍼히어로가 여러분을 도와줄 테니까요! 🦸‍♂️🦸‍♀️" }, { "title": "CSS _where() 의사 클래스 사용법", "url": "/posts/CSS-_where()-%EC%9D%98%EC%82%AC-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%82%AC%EC%9A%A9%EB%B2%95/", "categories": "CSS", "tags": "의사클래스", "date": "2023-07-01 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 👋 CSS 코드를 쓰면서 “아, 너무 복잡하다! 쉽게 할 수 없나?”라고 생각해본 적 있으시죠? 오늘은 그런 당신을 위해 특별히 준비한 마법의 주문, :where() 의사 클래스에 대해 알아보려고 합니다. 이걸 알면 당신도 CSS 마법사! 🧙‍♂️기본 사용법 :where()가 뭐길래?간단하게 말해서, :where()는 여러 개의 선택자를 하나로 묶어주는 역할을 합니다. 예를 들면 이렇게 사용할 수 있어요.:where(선택자1, 선택자2, 선택자3) { /* 여기에 스타일을 적어요! */}이런 식으로 작성하면 각 선택자에 대해 같은 스타일을 적용할 수 있어요. 깔끔하죠? 😎사례 1: 버튼 상태 스타일링 간단하게!일반적으로 버튼에 대해 여러 상태(focus, hover, active)에 같은 스타일을 적용하려면 이렇게 써야 합니다.button:focus,button:hover,button:active { background: blue;}하지만 :where()를 사용하면, 간결하게 작성할 수 있어요!button:where(:focus, :hover, :active) { background: blue;}사례 2: 다양한 버튼에 일괄 적용? No Problem!:where(button, input[type=\"button\"], input[type=\"reset\"], input[type=\"submit\"]) { appearance: none; cursor: pointer; /* 여기에 더 많은 스타일! */}본래라면 이렇게 길게 작성해야 할 코드도, :where()를 활용하면 한 줄로 끝낼 수 있습니다. 간편하죠? 🤩조합 마스터: 선택자 + 상태 = 🎉상태와 여러 요소를 같이 적용하고 싶다면, :where()를 조합하면 완성! 아래 코드는 :where()를 두 번 사용해 복잡한 상황을 간단하게 해결한 예시입니다.:where(button, input[type=\"button\"], input[type=\"reset\"], input[type=\"submit\"]):where(:focus, :hover, :active) { background: blue;}그래서 :where()가 대단한 이유는?여기서 잠깐, :where()의 장점을 재확인해 볼까요? 코드를 간결하게 만들어줘요: 불필요한 중복을 줄이고, 가독성을 높여줍니다. 오류에 대한 허용성: 오타 하나로 모든 스타일이 망가지지 않아요. 🎉정리: 이제 당신도 CSS 마법사!이제 :where()를 배웠으니, CSS 문제를 해결하는 건 식은 죽 먹기겠죠? 다음에 또 다른 마법의 주문으로 찾아뵙겠습니다! 함께해주신 여러분 감사합니다! 🌈🦄" }, { "title": "깃허브 액션으로 즐거운 자동화 여정 시작하기", "url": "/posts/%EA%B9%83%ED%97%88%EB%B8%8C-%EC%95%A1%EC%85%98%EC%9C%BC%EB%A1%9C-%EC%A6%90%EA%B1%B0%EC%9A%B4-%EC%9E%90%EB%8F%99%ED%99%94-%EC%97%AC%EC%A0%95-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/", "categories": "JavaScript", "tags": "깃허브, 액션, 자동화", "date": "2023-06-20 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 깃허브 액션(GitHub Actions)으로 프로젝트를 자동화하는 여정에 대해 이야기하겠습니다. 깃허브 액션은 특정 이벤트가 발생할 때 자동으로 실행되도록 설정할 수 있는 도구인데요, 지금부터 그 방법에 대해 함께 알아봅시다!프로젝트 생성하고 깃허브에 올리기 ✨첫번째 단계는 React 앱을 생성하는 것이에요. 아래 명령어로 한 번 해볼까요?$ npx create-react-app github-actions-setup-node그 다음, 프로젝트를 깃허브에 올립니다. 이렇게 명령어를 입력하면 금방 올라가니까 엄청 쉽죠? 😊$ cd github-actions-setup-node$ git remote add origin https://github.com/YourGitHubID/github-actions-setup-node.git$ git branch -M main$ git push -u origin mainnpm 패키지 설치하기 📦자, 이제 깃허브 액션을 만들기 위해 npm 패키지를 설치해볼게요. 아래와 같은 폴더와 파일을 만들어봅시다..github/workflows/ci.yml그리고 이렇게 입력해주세요!name: Our CIon: pushjobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - run: npm ci좋아요, 이제 push 이벤트가 발생하면 액션이 실행되는 것을 확인할 수 있을 거에요!테스트 실행과 앱 빌드 🏗️이제 마지막 단계네요! 워크플로우 파일을 수정하여 테스트를 실행하고 앱을 빌드해봅시다. 다음 내용을 ci.yml 파일에 추가해주세요!- run: npm test- run: npm run build그럼 테스트가 실행된 후 앱이 빌드되는 걸 볼 수 있을 거에요. 깃허브 Actions 탭에서 확인해보세요!마치며 🌟우리는 지금 깃허브 액션으로 자동화를 설정하는 방법을 배웠어요! 엄청 쉽죠? 이제 여러분도 자동화 마스터가 될 수 있을 거에요! 💪그럼, 행복한 코딩 되세요! 🚀" }, { "title": "ESLint 설정 가이드 처음부터 마스터까지", "url": "/posts/ESLint-%EC%84%A4%EC%A0%95-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%B2%98%EC%9D%8C%EB%B6%80%ED%84%B0-%EB%A7%88%EC%8A%A4%ED%84%B0%EA%B9%8C%EC%A7%80/", "categories": "JavaScript", "tags": "ESLint, 설정가이드", "date": "2023-06-19 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 너무나도 유명한 JavaScript 프로젝트의 베스트 프렌드, ESLint 설정 방법에 대해 다뤄볼게요! 🚀 이제 각 옵션을 하나하나 친절하고 재미있게 풀어볼 시간이에요! 준비됐나요? 시작해볼까요?ESLint 설정 파일 만들기: 어떤 형식을 선택할까? 🤔우리 ESLint는 정말 다양한 형식의 파일을 지원하는 녀석이에요. JSON, YAML, JavaScript 중에서 택 한 형식으로 설정 파일을 만들 수 있답니다. 파일 이름은 무조건 .eslintrc로 시작해야 하고, 그 뒤에는 우리가 선택한 형식의 확장자가 붙어요.{ \"extends\": [\"react-app\", \"react-app/jest\"]}🔍 참고 사항: 개인 프로젝트를 작성할 때는 package.json 파일 안의 eslintConfig 속성으로 ESLint를 설정할 수도 있어요. 하지만, 팀 프로젝트에서는 별도의 설정 파일을 사용하는 것이 훨씬 깔끔하답니다!root 옵션: 설정 파일의 기준점을 정해요! 📍ESLint 설정 시, 한 프로젝트 안에서 여러 개의 설정 파일을 사용할 수 있는 게 특징이에요. root 옵션이 true로 설정된 곳까지만 올라가서 설정 파일을 찾아볼거에요.이런 식으로 파일 경로를 정해봅시다:.eslintrc.jsonpackages/project-a/.eslintrc.jsonpackages/project-b/.eslintrc.json💡 Tip: 설정 파일이 하나뿐인 코드 저장소에서도 root 옵션을 true로 설정해두면 안전해져요!plugins 옵션: ESLint를 더욱 풍성하게 해볼까요? 🎨이제 우리 ESLint에 다양한 규칙을 추가해볼 차례에요. 이걸 가능하게 해주는 건 바로 plugins 옵션이랍니다! 여러 플러그인을 통해 ESLint를 풍성하게 꾸며봅시다.{ \"plugins\": [\"import\", \"react\"]}🛠 중요: 플러그인을 추가하기 전에 개발 의존성으로 설치해야 해요! 그리고 꼭 기억하세요, 플러그인을 추가한다고 해서 바로 활성화되는 것은 아니에요. 어떤 규칙을 적용할지는 extends 나 rules 옵션에서 따로 설정해줘야 한답니다.우리가 함께 ESLint 설정 파일을 만들어본 것 어떠셨나요? 🌟 이제 여러분이 만들어갈 프로젝트에 ESLint 설정이 완벽하게 적용되길 바라며, 다음에 또 만나요! 👋" }, { "title": "타입스크립트 마법사가 되어보자!", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%A7%88%EB%B2%95%EC%82%AC%EA%B0%80-%EB%90%98%EC%96%B4%EB%B3%B4%EC%9E%90!/", "categories": "JavaScript", "tags": "타입스크립트", "date": "2023-06-18 20:00:00 +0900", "snippet": "안녕하세요! 여러분이 오늘 배울 주제는 바로바로, ‘타입스크립트 컴파일러’입니다. 그럼 바로 시작해볼까요? 🚀타입스크립트 컴파일러, 그것이 무엇인가요?이름만 들어도 어렵게 느껴지는 ‘컴파일러’! 근데 이 친구는 자바스크립트를 편리하게 쓰려고 우리 곁에 왔답니다! 😊타입스크립트 컴파일러는 우리가 작성한 타입스크립트 코드를 자바스크립트 코드로 바꿔주는 중요한 도구입니다. 즉, 이 친구 덕분에 타입스크립트로 만든 코드를 인터넷 브라우저에서 돌릴 수 있는 거죠!이제, 이 친구와 친해져 볼까요? 🤝타입스크립트 컴파일러 설치하기, 쉽죠?‘설치’라는 단어를 보고 놀라지 마세요! 설치 과정은 너무너무 쉽답니다. 아주 간단히 npm이라는 터미널 명령어로 할 수 있어요! 😎컴파일러를 설치할 때, 프로젝트 별로 서로 다른 버전을 사용할 수도 있으니, 프로젝트 범위에서 설치하는 게 좋아요. 그리고 설치가 잘 됐는지 확인하는 방법도 알려 드릴게요! 💡터미널에 이렇게 치면 돼요:$ npx tsc -v바로 버전 정보가 나올 거에요! 그럼 이제 시작해볼까요? 🌈첫 타입스크립트 코드 작성하기그럼 이제 실습으로 넘어가볼게요! 간단하게 ‘hello.ts’라는 파일을 만들고, 아래와 같이 코드를 작성해볼까요? 👇let message = \"안녕하세요!\";console.log(message);이 코드를 보고, “이거 자바스크립트 코드 아닌가요?”라고 생각하실 수도 있는데요, 사실 타입스크립트는 자바스크립트의 모든 문법을 포함하고 있어요! 그래서 이 코드는 타입스크립트 코드이기도 하답니다! 🥳이제 이 파일을 자바스크립트로 변환해볼까요? 그러려면 다음과 같이 명령어를 치면 돼요:$ npx tsc hello.ts그럼 이제, 눈에 띄게 변한 ‘hello.js’ 파일이 생겼을 거에요! 한번 열어볼까요? 🧐타입 어노테이션, 무엇일까요? 🤔아! 잠깐만요, 여러분! 자바스크립트와 타입스크립트의 차이점 중 하나를 잊어버렸어요. 바로 ‘타입 어노테이션’입니다!타입 어노테이션은 변수에 어떤 종류의 값이 들어갈지를 알려주는 역할을 해요. 😇이렇게요:let message: string = \"안녕하세요!\";이제 ‘string’이라고 적어줘서, ‘message’라는 변수에는 문자열만 들어갈 수 있다고 명시해 준 거에요!그럼, 여러분의 타입스크립트 여정이 행복하길 바라며, 이만 인사를 드릴게요. 안녕히 가세요! 🌟" }, { "title": "React Hook Form 마스터하기", "url": "/posts/React-Hook-Form-%EB%A7%88%EC%8A%A4%ED%84%B0%ED%95%98%EA%B8%B0/", "categories": "JavaScript", "tags": "React, HookForm", "date": "2023-06-17 20:00:00 +0900", "snippet": "안녕하세요 여러분! 오늘은 빠르게 혁명을 일으키고 있는 React Hook Form을 함께 알아보도록 할게요. 요즘 개발자들 사이에서 핫한 이 주제, 과연 어떤 점에서 다들 찬사를 보내는지 한번 같이 파해쳐 보도록 합시다!로그인 폼 만들기 🛠️먼저, React Hook Form을 마스터하기 위해 기본적인 로그인 폼을 만들어볼까요? 아래와 같이 간단한 JSX 마크업을 시작으로 우리의 모험을 시작해봅시다!function LoginForm() { return ( &lt;form&gt; &lt;label htmlFor=\"email\"&gt;이메일&lt;/label&gt; &lt;input id=\"email\" type=\"email\" placeholder=\"test@email.com\" /&gt; &lt;label htmlFor=\"password\"&gt;비밀번호&lt;/label&gt; &lt;input id=\"password\" type=\"password\" placeholder=\"****************\" /&gt; &lt;button type=\"submit\"&gt;로그인&lt;/button&gt; &lt;/form&gt; );}export default Form;별도의 라이브러리 없이도 이 정도의 코드 작성은 가능하지 않을까요? 이제 여기에 React Hook Form의 힘을 더해보도록 합시다!React Hook Form 연결하기 🔗자, 이제 우리의 폼에 React Hook Form을 연결해 볼 시간이에요! 그러려면 useForm이라는 훅을 사용해야 해요. 우리 로그인 폼에 이 라이브러리를 연결해볼까요?import { useForm } from \"react-hook-form\";function LoginForm() { const { register, handleSubmit } = useForm(); return ( &lt;form onSubmit={handleSubmit((data) =&gt; alert(JSON.stringify(data)))}&gt; &lt;label htmlFor=\"email\"&gt;이메일&lt;/label&gt; &lt;input id=\"email\" type=\"email\" placeholder=\"test@email.com\" {...register(\"email\")} /&gt; &lt;label htmlFor=\"password\"&gt;비밀번호&lt;/label&gt; &lt;input id=\"password\" type=\"password\" placeholder=\"****************\" {...register(\"password\")} /&gt; &lt;button type=\"submit\"&gt;로그인&lt;/button&gt; &lt;/form&gt; );}export default Form;자, 이제 로그인 버튼을 누르면 입력한 데이터가 알림으로 표시되게 됩니다! 어떤가요, 생각보다 간단하지 않나요? 😊중복 제출 방지하기 ⏳때로는 사용자가 너무 빨리 버튼을 누르면서 폼이 여러 번 제출되는 문제가 발생할 수 있어요. 그래서 우리는 중복 제출을 방지하기 위한 작업을 추가해 보겠습니다!function LoginForm() { const { register, handleSubmit, formState: { isSubmitting }, } = useForm(); return ( &lt;form onSubmit={handleSubmit(async (data) =&gt; { await new Promise((r) =&gt; setTimeout(r, 1000)); alert(JSON.stringify(data)); })} &gt; &lt;label htmlFor=\"email\"&gt;이메일&lt;/label&gt; &lt;input id=\"email\" type=\"email\" placeholder=\"test@email.com\" {...register(\"email\")} /&gt; &lt;label htmlFor=\"password\"&gt;비밀번호&lt;/label&gt; &lt;input id=\"password\" type=\"password\" placeholder=\"****************\" {...register(\"password\")} /&gt; &lt;button type=\"submit\" disabled={isSubmitting}&gt; 로그인 &lt;/button&gt; &lt;/form&gt; );}export default Form;이제 로그인 버튼은 제출이 완료될 때까지 비활성화 됩니다. 사실 React Hook Form은 너무 빨라서 지연시간을 주지 않으면 버튼이 비활성화 되는 것을 볼 수 없어요! 😆입력값 검증하기 🕵️‍♂️마지막으로 우리는 입력값 검증을 추가해 볼 것입니다. 이메일과 비밀번호는 필수 항목이며, 각각 특정한 규칙을 충족해야 한다는 것을 우리 모두 알고 있죠?function LoginForm() { const { register, handleSubmit, } = useForm(); return ( &lt;form onSubmit={handleSubmit((data) =&gt; { alert(JSON.stringify(data)); })} &gt; &lt;label htmlFor=\"email\"&gt;이메일&lt;/label&gt; &lt;input id=\"email\" type=\"email\" placeholder=\"test@email.com\" {...register(\"email\", { required: true, pattern: /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$/ })} /&gt; &lt;label htmlFor=\"password\"&gt;비밀번호&lt;/label&gt; &lt;input id=\"password\" type=\"password\" placeholder=\"****************\" {...register(\"password\", { required: true, minLength: 8 })} /&gt; &lt;button type=\"submit\"&gt; 로그인 &lt;/button&gt; &lt;/form&gt; );}export default Form;위 코드를 통해 이메일과 비밀번호 필드에 각각 필요한 검증 규칙을 추가했어요. 그러면 사용자가 유효하지 않은 데이터를 입력하려고 하면, 오류 메시지를 받게 됩니다!마무리 🎉자, 여러분! 우리가 함께 React Hook Form 라이브러리를 이용하여 로그인 폼을 만들었습니다. 어떤가요? 생각보다 간단하고 재미있지 않나요? 🎉" }, { "title": "React에서 외부 스크립트 불러오기 쉽게 알아보자!", "url": "/posts/React%EC%97%90%EC%84%9C-%EC%99%B8%EB%B6%80-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0-%EC%89%BD%EA%B2%8C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90!/", "categories": "JavaScript", "tags": "React, 외부스크립트", "date": "2023-06-16 20:00:00 +0900", "snippet": "안녕하세요 여러분! 오늘은 React 프로젝트에서 외부 스크립트를 불러오는 방법에 대해 친절하게, 그리고 발랄하게 알아보려고 합니다! 😉HTML 문서 안에 컴퓨터 안에 있는 선반 위에 먼지가 쌓인 오래된 책을 찾아내듯이, 가끔은 React 프로젝트에서도 npm 패키지가 제공되지 않는 외부 스크립트를 불러와야 할 때가 있어요. 그럴 때는 어떻게 해야 할까요? 🤔바로 HTML 문서의 &lt;script&gt; 태그를 사용하는 방법이 있어요! 직접 해보며 배워볼까요? 🛠️index.html 파일 수정하기 🔧우리가 사용하는 React 프로젝트에는 public 폴더 안에 index.html 파일이 먼저 인사를 하고 있어요. 이 파일을 열어서 &lt;script&gt; 요소를 추가해주면, 외부 자바스크립트를 불러올 수 있답니다!&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;React App&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script async src=\"https://unpkg.com/lodash\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;하지만 주의해야 할 것이 있어요. 이 방법은 선택적으로 스크립트를 불러올 수 없다는 단점이 있어요. 그래서 모든 페이지에서 필요한 스크립트가 아니라면 이 방법은 추천하지 않아요. 😅동적으로 “그럼 다른 방법은 없을까?”라고 물어본 당신! 물론 있어요! 😊단 4줄의 자바스크립트 코드로 동적으로 &lt;script&gt; 요소를 추가할 수 있어요. 어떻게 하는지 한번 볼까요?const script = document.createElement(\"script\");script.src = \"https://unpkg.com/lodash\";script.async = true;document.body.appendChild(script);아주 심플하지 않나요? 😄 이제 본격적으로 React 컴포넌트에서 해보도록 하죠!React 컴포넌트에서 외부 스크립트 불러오기 🎉React 컴포넌트에서 외부 스크립트를 불러오려면 어떻게 해야 할까요? 바로 useEffect() 훅 함수를 이용하는 방법이 있어요!import { useEffect } from \"react\";function Input() { useEffect(() =&gt; { const script = document.createElement(\"script\"); script.src = \"https://unpkg.com/lodash\"; script.async = true; document.body.appendChild(script); }); return &lt;input /&gt;;}이제 &lt;Input/&gt; 컴포넌트가 렌더링될 때 외부 자바스크립트도 불러올 수 있게 되었어요. 🥳스크립트 중복 삽입 방지 🚫하지만 문제가 하나 생겨요. 여러 번 렌더링되면 스크립트가 중복되어 삽입되니까요.그래서 우리는 useEffect() 훅 함수의 두 번째 인자로 빈 배열을 넘겨주면 됩니다!useEffect(() =&gt; { const script = document.createElement(\"script\"); script.src = \"https://unpkg.com/lodash\"; script.async = true; document.body.appendChild(script);}, []);이렇게 하면 스크립트가 한 번만 삽입되고, 여러 번 중복되어 삽입되지 않아요. 🎊어때요, 여러분? React 프로젝트에서 외부 스크립트를 불러오는 방법을 배우니까 좀 더 넓은 세상을 볼 수 있게 된 것 같지 않나요? 😄여러분의 React 프로젝트가 더욱 더 풍성해지길 바라며, 오늘의 글을 마치겠습니다! 더 궁금한 것이 있다면 언제든지 물어봐주세요~ 🌈" }, { "title": "구글 지도로 당신의 웹페이지를 더 활기차게 만들어봐요!", "url": "/posts/%EA%B5%AC%EA%B8%80-%EC%A7%80%EB%8F%84%EB%A1%9C-%EB%8B%B9%EC%8B%A0%EC%9D%98-%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80%EB%A5%BC-%EB%8D%94-%ED%99%9C%EA%B8%B0%EC%B0%A8%EA%B2%8C-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B4%90%EC%9A%94!/", "categories": "JavaScript", "tags": "구글지도, 웹페이지", "date": "2023-06-15 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 모든 이가 쉽게 구글 지도를 자신의 웹페이지에 올릴 수 있는 방법을 배워볼 거에요. 그럼 바로 시작해 볼까요?1단계: API 키 발급 받기 🗝️우선, 우리가 필요한 첫 번째 재료는 구글 Maps API 키에요. 키를 받으려면 구글 클라우드 콘솔에서 API 키를 발급 받아야 해요. 하지만 걱정하지 마세요, 전 당신들이 성공할 수 있을 거라 믿어요! 💪2단계: 웹페이지에 지도 넣기 🗺️이제 당신의 웹페이지에 지도를 놓을 준비가 된 거에요. 아래와 같이 HTML 코드를 작성해서 지도를 보여줄 &lt;div&gt; 요소를 만들어주세요!&lt;body&gt; &lt;div id=\"map\" style=\"height: 600px;\"&gt;&lt;/div&gt;&lt;/body&gt;여기서 중요한 점은 높이를 꼭 지정해 주어야 한다는 거에요! 그렇지 않으면 지도가 보이지 않아요. 🙅‍♂️3단계: 구글 Maps API 스크립트 불러오기 📥이제는 구글 Maps API의 마법서를 불러올 차례에요. 아래 코드처럼 두 개의 **&lt;head&gt; &lt;script defer src=\"./index.js\"&gt;&lt;/script&gt; &lt;script defer src=\"https://maps.googleapis.com/maps/api/js?key=&lt;API 키&gt;&amp;callback=initMap\"&gt;&lt;/script&gt;&lt;/head&gt;여기서는 두 개의 파라미터를 추가해 주었는데요, key 파라미터에는 방금 받은 API 키를 넣어주시고, callback 파라미터에는 지도가 준비되면 호출할 함수 이름을 넣어주세요!4단계: 지도 보여주기 🌍드디어, 지도를 보여줄 시간이에요! 아래처럼 index.js 파일을 만들고 함수를 작성해주세요.window.initMap = function () { const map = new google.maps.Map(document.getElementById(\"map\"), { center: { lat: 37.5400456, lng: 126.9921017 }, zoom: 10, });};참 쉽죠? 😄 이제 웹페이지에 서울 시내가 보일 거에요!5단계: 마커로 위치 표시하기 📍마지막 단계에요! 아래 코드를 이용해서 서울의 몇몇 특별한 장소에 마커를 표시해봐요!const malls = [ { label: \"C\", name: \"코엑스몰\", lat: 37.5115557, lng: 127.0598387 }, // 여기에 다른 쇼핑몰 정보를 추가하세요!];malls.forEach(mall =&gt; { new google.maps.Marker({ position: { lat: mall.lat, lng: mall.lng }, map, title: mall.name, label: mall.label, });});이렇게 해서, 당신의 웹페이지에 구글 지도를 추가하는 방법을 배웠어요! 이제 당신도 지도 마법사가 되었네요! 이 세상 어디든 여러분의 웹페이지에서 볼 수 있어요! 😄" }, { "title": "Emotion과 함께 편안하게 CSS 스타일링하기!", "url": "/posts/Emotion%EA%B3%BC-%ED%95%A8%EA%BB%98-%ED%8E%B8%EC%95%88%ED%95%98%EA%B2%8C-CSS-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81%ED%95%98%EA%B8%B0!/", "categories": "JavaScript", "tags": "CSS, Emotion", "date": "2023-06-14 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 놀랍도록 강력하면서도 깜찍한 라이브러리, Emotion을 사용하여 React 컴포넌트를 아름답게 꾸미는 방법을 알아보겠습니다. 이제 손을 힘껏 털고, 키보드 위로 손을 가져가 보세요! 😁Emotion의 세계로 한 발짝! 🌈우리는 여기서 ‘Emotion’이라는 라이브러리를 사용하여 마치 화가가 미술지에 색을 입히듯, 우리의 웹 사이트에 생기를 불어넣을 거에요. 이 라이브러리는 ‘CSS-in-JS’ 방식을 사용해서 스타일을 입히는 거랍니다. 여러분도 무지개 같은 화려한 웹 페이지를 만들 준비가 되셨나요? 🌈패키지 설치하기 🛠️먼저, 우리는 Emotion을 우리의 프로젝트에 설치할 필요가 있어요. 이를 위해 npm이라는 패키지 매니저를 사용하면 금방 설치할 수 있어요! 여러분의 프로젝트가 React가 아니라면 걱정하지 마세요! Emotion은 다른 자바스크립트 프로젝트에서도 사용할 수 있답니다! 🌟// React 프로젝트에서는 이렇게 설치해요!npm install @emotion/react @emotion/styled기본 문법 익히기 📚이제 기본 문법을 배워 볼 거에요. Emotion에서는 css() 함수를 사용해서 스타일을 정의할 수 있어요. 여기에 우리가 원하는 스타일을 넣어주면 된답니다! 이렇게 말이죠!/** @jsxImportSource @emotion/react */import { css } from \"@emotion/react\";function MyComponent() { return ( &lt;div css={css({ backgroundColor: \"yellow\", })} &gt; 노란색 영역 &lt;/div&gt; );}그리고 이 스타일을 원하는 HTML 요소에 적용시킬 수 있어요! 🎨JSX Pragma와 친해지기 🤗여러분이 코드를 보면 /** @jsxImportSource @emotion/react */ 라는 뭔가 신기한 코드를 볼 수 있어요. 이건 Babel 트랜스파일러에게 “이 JSX를 Emotion의 jsx() 함수를 사용하여 변환해줘!”라고 알려주는 역할을 한답니다. 이렇게 하면 우리가 정의한 스타일이 제대로 적용된답니다! ✨버튼 만들기에 도전! 🎮이제 본격적으로 버튼을 만들어 볼 거에요! GitHub에서 보신 그런 멋진 버튼을 만들어볼텐데, 어렵게 생각하지 마세요! 아래 코드를 따라하면 금방 만들 수 있어요!/** @jsxImportSource @emotion/react */function Button({ children }) { return ( &lt;button css= &gt; {children} &lt;/button&gt; );}마법같죠? 이렇게 우리의 React 앱에서 이 아름다운 버튼을 사용할 수 있게 되었어요! 😁마무리 🌟여러분! 여러분이 만든 아름다운 버튼은 어떤가요? 브라우저에서 소스를 확인해보면 Emotion이 자동으로 만들어준 클래스 이름이 있는 것을 확인할 수 있을 거에요! 자, 이제 여러분도 Emotion 마법사가 되었습니다! ✨다음에도 더 많은 마법 같은 코딩 이야기로 찾아뵐게요! 그때 봐요! 🌈" }, { "title": "리액트로 라디오 버튼 만들기", "url": "/posts/%EB%A6%AC%EC%95%A1%ED%8A%B8%EB%A1%9C-%EB%9D%BC%EB%94%94%EC%98%A4-%EB%B2%84%ED%8A%BC-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "JavaScript", "tags": "React, 라디오버튼", "date": "2023-06-12 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 흥미진진한 리액트 세계 속으로 함께 여러분을 안내하려고 합니다. 😊 오늘의 주인공은 바로 ‘라디오 버튼’이에요! 딱딱한 개발 언어 대신 깔끔하고 이해하기 쉬운 한국어로 풀어볼게요. 함께 해봅시다! 🚀첫번째 단계: 라디오 컴포넌트 만들기우리가 먼저 해야 할 일은 개별 라디오 버튼을 나타내는 리액트 컴포넌트를 만드는 거에요. HTML에서는 &lt;input&gt; 요소의 type 속성을 radio로 설정하면 간단하게 라디오 버튼을 만들 수 있답니다!또한, 텍스트를 클릭했을 때도 라디오 버튼이 선택될 수 있도록 &lt;label&gt; 요소로 &lt;input&gt; 요소와 children prop 모두 감싸줄 거에요. 자세히 보면 이렇게 생겼어요! 👇function Radio({ children, value, name, defaultChecked, disabled }) { return ( &lt;label&gt; &lt;input type=\"radio\" value={value} name={name} defaultChecked={defaultChecked} disabled={disabled} /&gt; {children} &lt;/label&gt; );}두번째 단계: 라디오 그룹 컴포넌트 만들기라디오 버튼은 보통 둘이서 한 팀을 이뤄서 나오곤 해요. 그래서 여러 개의 라디오 버튼을 담을 수 있는 리액트 컴포넌트를 만들거에요. HTML의 &lt;legend&gt; 요소를 이용하여 그룹의 목적을 텍스트로 표시해줄 거고, &lt;fieldset&gt; 요소를 이용하여 여러 개의 라디오 버튼을 묶어줄 거에요. 마법같죠? 😲 이렇게 해보세요! 👇function RadioGroup({ label, children }) { return ( &lt;fieldset&gt; &lt;legend&gt;{label}&lt;/legend&gt; {children} &lt;/fieldset&gt; );}세번째 단계: 비제어 컴포넌트 활용하기우리가 만든 &lt;Radio/&gt;와 &lt;RadioGroup/&gt; 컴포넌트는 비제어 컴포넌트로 사용할 수 있어요. 비제어 컴포넌트는 브라우저가 상태를 관리하는 컴포넌트에요. 자, 그럼 이제 사용자가 원하는 연락 방법을 선택할 수 있는 간단한 양식 UI를 만들어볼게요. 아래와 같이 코드를 작성하면 돼요! 😎import RadioGroup from \"./RadioGroup\";import Radio from \"./Radio\";function App() { return ( &lt;form onSubmit={(e) =&gt; { e.preventDefault(); alert(`${e.target.contact.value}를 통해 연락드리겠습니다!`); }} &gt; &lt;RadioGroup&gt; &lt;Radio name=\"contact\" value=\"EMAIL\" defaultChecked&gt; 이메일 &lt;/Radio&gt; &lt;Radio name=\"contact\" value=\"PHONE\"&gt; 전화 &lt;/Radio&gt; &lt;Radio name=\"contact\" value=\"FAX\"&gt; 팩스 &lt;/Radio&gt; &lt;Radio name=\"contact\" value=\"MAIL\" disabled&gt; 우편 &lt;/Radio&gt; &lt;/RadioGroup&gt; &lt;button&gt;제출&lt;/button&gt; &lt;/form&gt; );}제출 버튼을 클릭해보세요, 선택된 연락 방법으로 알림창이 뜰 거에요! 😉마무리: Context 추가하기이제 마지막 단계에요! &lt;Radio/&gt;와 &lt;RadioGroup/&gt; 컴포넌트를 Controlled Components로 만들어볼 거에요. 이는 리액트가 상태 관리를 맡기기 위한 단계랍니다. 이렇게 하기 위해, 부모 컴포넌트인 &lt;RadioGroup/&gt;와 자식 컴포넌트인 &lt;Radio/&gt; 사이에 정보를 공유할 필요가 있어요.리액트의 createContext라는 함수를 이용해서 정보를 공유하기 위한 React Context 하나를 만들어봅시다! 🎉import { createContext } from \"react\";const RadioContext = createContext({});자세한 내용은 여기까지며 리액트로 라디오 버튼을 만드는 방법을 배워보았습니다. 함께 하느라 수고했습니다! 💖" }, { "title": "Jest로 완벽히 커버해보자!", "url": "/posts/Jest%EB%A1%9C-%EC%99%84%EB%B2%BD%ED%9E%88-%EC%BB%A4%EB%B2%84%ED%95%B4%EB%B3%B4%EC%9E%90!/", "categories": "JavaScript", "tags": "Jest", "date": "2023-06-11 20:00:00 +0900", "snippet": "안녕하세요, 코드의 모든 구석구석을 살펴보며 품질을 높여주는 Jest의 커버리지 기능을 함께 배워보려고 합니다. 준비되셨나요? 그럼 시작해봅시다!테스트 커버리지란 무엇인가요? 🧐먼저, 테스트 커버리지란 무엇일까요? 너무 어렵게 생각하지 마세요. 테스트 커버리지는 소프트웨어의 한 부분으로, 우리 코드의 어느 부분이 테스트되었는지를 알려줍니다.우리가 코드를 작성할 때 “이 부분은 정말 중요하니까 꼭 테스트해야지!” 라고 생각하는 부분이 있잖아요? 테스트 커버리지를 이용하면 그런 부분들이 제대로 테스트되었는지를 확인할 수 있습니다.높은 테스트 커버리지를 가진 소프트웨어는 사용자들이 더 신뢰하고 쉽게 사용할 수 있습니다. 쉽게 말해, “우리 코드 짱짱맨!” 이라고 자부할 수 있는 그런 지표가 바로 테스트 커버리지랍니다!Jest로 커버리지 확인하기 🕵️‍♂️Jest는 테스트 커버리지를 확인할 때 사용하는 테스팅 프레임워크입니다.Jest를 사용해서 테스트 커버리지를 확인하려면, 터미널에 아래와 같이 입력해주세요!jest --coverage마법같이! ✨ 터미널에는 테스트 커버리지에 대한 정보가 나타나게 됩니다. 그리고 테스트 커버리지의 결과도 굉장히 친절하게 퍼센트로 표시해줍니다. 진짜 마법이죠?커버리지 데이터를 더 정확하게 만들기 🎯그런데, Jest로 테스트 커버리지를 확인하다보면 “어? 이게 왜 이렇게 높지?” 하는 경우가 있을거에요. 이런 놀라움을 피하려면, collectCoverageFrom 옵션을 사용해서 커버리지 데이터를 더 정확하게 수집할 수 있답니다.다음은 jest.config.js 파일에서 collectCoverageFrom 옵션을 어떻게 설정하는지 보여주는 예시에요!module.exports = { collectCoverageFrom: ['**/*.[jt]s?(x)', '!**/*.stories.[jt]s?(x)'],};이렇게 설정하면, 파일 이름에 stories가 들어간 파일을 제외하고 모든 JavaScript와 TypeScript 파일에서 커버리지 데이터를 수집할 수 있습니다!커버리지 기준 설정하기 ⚖️마지막으로, 우리 프로젝트의 커버리지 기준을 설정해보겠습니다. 이 기준은 “우리 코드는 최소 이 정도는 테스트되어야 해!” 라는 것을 정하는 기준이에요.다음 코드는 jest.config.js 파일에서 coverageThreshold 옵션을 어떻게 설정하는지 보여줍니다.module.exports = { coverageThreshold: { './src/': { statements: 95, branches: 90, functions: 95, lines: 90, }, },};이 설정으로 인해, 우리는 자신있게 “우리 코드는 최소 90~95%는 테스트되었어!” 라고 말할 수 있게 됩니다. 놀라운 것은, 이 기준에 미치지 못하면 에러가 발생한다는 거에요!마치며 🎉자, 이렇게 Jest로 테스트 커버리지를 확인하는 방법에 대해 알아봤습니다. 이제 당신도 테스트 커버리지 마스터가 되어, 버그 없이 더 안전한 코드를 작성할 수 있을 것입니다!그럼 행복한 코딩 되세요~ 😊" }, { "title": "타입스크립트로 즐겁게 객체 순회하기", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EC%A6%90%EA%B2%81%EA%B2%8C-%EA%B0%9D%EC%B2%B4-%EC%88%9C%ED%9A%8C%ED%95%98%EA%B8%B0/", "categories": "JavaScript", "tags": "타입스크립트, 객체순회", "date": "2023-06-10 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 함께 ‘타입스크립트’라는 신비한 세계로 모험을 떠나보도록 할까요? 막연한 두려움은 잠시 접어두시고, 즐겁게 코딩의 세계로 빠져볼 시간이에요!오류 메시지, 내 친구 😅자, 우리가 타입스크립트로 진행하다 보면 어떤 오류 메시지들을 만나게 될거에요. 하지만 걱정 마세요! 이 친구들은 사실 우리에게 더 나은 코딩을 위해 도움을 주려고 나타난 친구들이랍니다. 지금부터 이 친구들을 잘 이해해서 스마트하게 코드를 짜보도록 해요!깜짝 등장! Object.keys() 👯const obj = { a: 1, b: 2, c: 3 };Object.keys(obj).forEach((key) =&gt; console.log(obj[key])); // 오류 발생 🚨먼저 Object.keys()라는 친구를 소개할게요! 이 친구는 객체의 모든 키들을 배열로 만들어 주는 역할을 해요. 하지만, 이 친구와 타입스크립트는 처음 보는 사이라서, 타입스크립트는 어떤 키가 올지 모르겠단 말이죠. 그래서 우리는 이렇게 말해주면 돼요.const obj: Record&lt;string, number&gt; = { a: 1, b: 2, c: 3 };Object.keys(obj).forEach((key) =&gt; console.log(obj[key])); // 문제 없어요! 😃“헤이! 타입스크립트 친구야, 모든 키는 문자열이라고! 그리고 그 키로 찾을 수 있는 값들은 숫자라고!” 📣키워드 스타! for-in 🌟const obj = { a: 1, b: 2, c: 3 };for (let key in obj) { console.log(obj[key]); // 오류 발생 🚨}다음은 for-in이라는 스타를 만나볼 차례에요! 이 친구도 키를 모두 찾아주는 역할을 하는데, 이 친구와 타입스크립트가 처음 만났을 때, 타입스크립트는 또 놀라버려요. 🙀 그래서 우리는 이렇게 말해주면 돼요.const obj: Record&lt;string, number&gt; = { a: 1, b: 2, c: 3 };for (let key in obj) { console.log(obj[key]); // 잘 돼요! 🌈}“안녕, 타입스크립트! 이번에도 모든 키는 문자열이라고! 그리고 그 키로 찾을 수 있는 값들은 숫자라고!” 🎤더 쉽게 순회하기 with Object.values() 🏃‍♂️const obj = { a: 1, b: 2, c: 3 };Object.values(obj).forEach((value) =&gt; console.log(value)); // 멋져요! 🌟마지막으로, 키를 건너뛰고 바로 값에 접근할 수 있는 Object.values() 친구를 소개할게요! 이 친구를 사용하면, 키 때문에 고민할 필요가 전혀 없어요! 타입스크립트도 이 친구를 보면서 “아~ 이제 이해했어!” 하고 더이상 오류 메시지를 보내지 않아요! 😎마무리하며 🎉우리가 타입스크립트의 세계에서 즐겁게 코딩하기 위해 알아야 할 것들은 이게 전부에요! 이제 여러분도 타입스크립트 오류 메시지에 더이상 놀라지 않고, 자유자재로 코드를 짤 수 있어요! 🚀" }, { "title": "NestJS로 뛰어들기!", "url": "/posts/NestJS%EB%A1%9C-%EB%9B%B0%EC%96%B4%EB%93%A4%EA%B8%B0!/", "categories": "JavaScript", "tags": "NextJS", "date": "2023-06-09 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 특별한 백엔드 프레임워크, NestJS를 함께 탐험할 거예요! 😊NestJS가 뭐에요?좀 더 쉽게 말하자면, NestJS는 웹 앱을 만들 때 ‘뒤에서 일어나는 일들을 도와주는 도구’라고 볼 수 있어요. 자바의 스프링이나 파이썬의 장고를 아시는 분들은 이해가 더 빠르겠죠? 근데 이제는 NestJS의 시대랍니다!NestJS와 Express의 관계 🤝알다시피, 자바스크립트 세계에서는 Express가 오랫동안 웹 프레임워크의 왕이었어요. 근데 NestJS가 등장하면서 이 트렌드가 바뀌고 있답니다! NestJS는 Express보다 더 많은 기능을 제공해서, 개발자들이 더 쉽게 웹 앱을 만들 수 있게 도와줘요.NestJS의 특징들 🔍강력한 CLI 도구NestJS는 CLI (명령 줄 인터페이스) 도구를 제공하는데요, 이 도구로 더 빠르게, 더 편리하게 프로젝트를 시작할 수 있어요! 이 도구를 설치하려면 터미널에 아래와 같은 명령어를 입력해 주세요:$ npm i -g @nestjs/cli프레임워크의 확장성NestJS는 기업용 앱을 개발하는 데도 충분해요! 쉽게 확장할 수 있고, OOP (객체 지향 프로그래밍), DI (의존성 주입), AOP (과점 지향 프로그래밍) 같은 트렌드를 따라가서 고품질의 코드를 작성할 수 있게 도와준답니다!NextJS와 NestJS 착각 주의!“NextJS”와 “NestJS” 두 이름이 비슷해서 헷갈리는 경우가 많아요! NextJS는 리액트 기반 SSR 프레임워크이고, NestJS는 백엔드 API를 개발할 때 사용해요. 이름 헷갈리지 않게 조심하세요! 😉간단한 실습으로 NestJS 시작하기 🏃‍♂️CLI 도구를 설치했다면, nest 명령어로 NestJS 프로젝트를 시작할 준비가 된 거예요! 터미널에서 다음 명령어를 입력하면 NestJS의 세계로 뛰어들 수 있답니다:$ nest new my-nestjs-project그러면 NestJS 프로젝트가 생성되고, 여러분은 NestJS 마법을 체험할 준비가 완료된 거예요!마무리 🎉이제 NestJS의 기본적인 부분들을 배웠으니, 여러분도 NestJS 마법사가 될 준비가 되셨네요! 함께 더 깊게 NestJS를 배워보며 코딩의 세계를 탐험해요! 🚀" }, { "title": "NestJS로 쉽고 재미있게 REST API 만들기", "url": "/posts/NestJS%EB%A1%9C-%EC%89%BD%EA%B3%A0-%EC%9E%AC%EB%AF%B8%EC%9E%88%EA%B2%8C-REST-API-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "JavaScript", "tags": "NextJS, RESTAPI", "date": "2023-06-08 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 모두의 친구 NestJS와 함께 REST API를 만들어 볼거예요. REST API는 한마디로 말해서 다양한 프로그램이 서로 소통할 수 있게 해주는 중간 다리 같은 역할을 해요. NestJS는 이런 API를 만드는 데 정말 유용한 친구랍니다! 😄실습 프로젝트 시작하기 💻우리는 먼저 NestJS 프로젝트를 시작해야해요. 터미널에서 아래와 같은 명령어를 입력해서 프로젝트를 만들어 봅시다!$ nest new our-nestjs이제 NestJS의 세상으로 한 발자국 더 다가갔어요! 🌟코드 자동 생성 🛠이제 본격적으로 코드를 작성해볼 차례에요. 근데 코드를 모두 손으로 작성하려면 시간이 너무 오래 걸리죠? NestJS는 이런 번거로움을 덜어주기 위해 자동으로 코드를 생성해주는 기능을 제공해요. 아래 명령어를 통해 필요한 파일들을 한 번에 생성해봅시다!$ nest generate resource users와! 이제 필요한 파일들이 모두 생성되었어요. 굉장히 편리하죠? 🥳엔티티 클래스 작성하기 🏗이제 데이터를 어떻게 다룰지 정해야 할 차례에요. 우리가 만들 유저 정보를 관리하는 엔티티 클래스를 작성해봅시다. 아래와 같이 파일을 작성해볼까요?export class User { id: number; name: string; email: string; phone?: string; createdAt: Date; updatedAt?: Date;}엔티티 클래스에는 유저의 정보를 나타내는 여러 속성들이 있는데요, 이 중 createdAt과 updatedAt 속성은 데이터가 언제 생성되었는지, 수정되었는지를 알려주는 친구들이에요. 👀DTO 클래스 꾸미기 🎨이제 데이터를 주고 받을 때 사용할 DTO 클래스를 작성해볼게요. DTO 클래스는 데이터를 안전하게 전달해주는 역할을 해요. 우리가 만들 CreateUserDto와 UpdateUserDto 클래스에는 유저 정보를 받을 속성들을 정의해봅시다. 이렇게 해보세요!export class CreateUserDto { name: string; email: string; phone?: string;}이렇게 작성하면 유저를 생성할 때 필요한 정보만 담을 수 있어요. 우리가 직접 관리할 필요가 없는 id, createdAt, updatedAt 속성들은 제외했어요. 즉, 불필요한 정보는 받지 않겠다는 거죠! 🚀마무리 🎉여러분들도 NestJS를 사용해서 멋진 프로젝트를 시작해보세요! NestJS와 함께라면 누구든지 쉽고 빠르게 API를 개발할 수 있어요. 그럼 모두 NestJS와 함께 행복한 코딩 시간 되세요! 👋" }, { "title": "NestJS에서 재미있게 로거 사용하기!", "url": "/posts/NestJS%EC%97%90%EC%84%9C-%EC%9E%AC%EB%AF%B8%EC%9E%88%EA%B2%8C-%EB%A1%9C%EA%B1%B0-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0!/", "categories": "JavaScript", "tags": "NextJS, 로거", "date": "2023-06-07 20:00:00 +0900", "snippet": "안녕하세요, 개발자 여러분! 🌟 오늘은 여러분의 NestJS 앱에서 로거를 어떻게 활용하고 꾸밀 수 있는지 살펴보겠습니다. NestJS 로거는 앱에서 발생하는 여러 이벤트를 기록해 문제가 발생했을 때 원인을 파악하는 데 도움을 줍니다.로거 소개와 설치 🛠️먼저 NestJS 프로젝트를 하나 만들어야 겠죠? 아래 명령어로 새 프로젝트를 만들어 봅시다.$ nest new our-nestjsNestJS CLI 도구의 ‘nest new’ 명령어를 실행하면, 꽤나 친절하게도 프로젝트를 만들어 줍니다. 아, 이 시간에 패키지 매니저를 선택해야 하는데요. npm, yarn, pnpm 중에서 선택하세요. 😊로거 사용해 보기 😎로거를 사용하려면, @nestjs/common 패키지에서 Logger 클래스를 불러와야 합니다. 이 클래스를 사용하면 log(), warn(), debug()와 같은 메서드를 호출할 수 있습니다. 간단하죠? 😁로거 클래스 만들기 🧑‍🔧Logger 클래스를 사용하면 로그 메시지 앞에 클래스 이름을 함께 출력할 수 있습니다. 그러면 로그 메시지가 어느 클래스에서 찍혔는지 쉽게 알 수 있어요. 이제 AppService 클래스에서 로그를 찍어보겠습니다.import { Injectable, Logger } from \"@nestjs/common\";@Injectable()export class AppService { private readonly logger = new Logger(AppService.name); getHello(): string { this.logger.debug(\"Logging...\"); return \"Hello World!\"; }}로그 확인 🧐자, 이제 AppService 클래스에서 로그를 찍어봤으니, AppController 클래스에서도 해볼 차례입니다. 이번에는 warn 수준의 로그를 찍어볼까요?import { Controller, Get, Logger } from \"@nestjs/common\";import { AppService } from \"./app.service\";@Controller()export class AppController { private readonly logger = new Logger(AppController.name); constructor(private readonly appService: AppService) {} @Get() getHello(): string { this.logger.warn(\"Logging...\"); return this.appService.getHello(); }}로거 확장하기 🚀이모지로 로그 더 재미있게 만들기 😄아래 코드처럼 로그를 남길 때 메시지 앞에 특정 이모지를 함께 출력되도록 로거를 확장해볼까요? 이렇게 하면 로그 확인할 때 더 재미있게 할 수 있답니다!import { ConsoleLogger, Injectable } from \"@nestjs/common\";@Injectable()export class MyLogger extends ConsoleLogger { debug(message: any, ...optionalParams: any[]) { super.debug(`🐛 ${message}`, ...optionalParams); } warn(message: any, ...optionalParams: any[]) { super.warn(`🚨 ${message}`, ...optionalParams); }}확장한 로거 설정하기 🛠️확장한 로거를 사용하려면 main.ts 파일에서 설정을 해주어야 해요. NestFactory.create()를 호출할 때 logger 옵션으로 확장한 로거 클래스의 인스턴스를 넘겨주면 됩니다.import { NestFactory } from \"@nestjs/core\";import { AppModule } from \"./app.module\";import { MyLogger } from \"./my-logger\";async function bootstrap() { const app = await NestFactory.create(AppModule, { logger: new MyLogger(), }); await app.listen(3000);}bootstrap();이제 앱을 구동하고 GET / 엔드포인트를 호출해보세요. 로그가 이모지와 함께 찍히는 것을 확인할 수 있을 거에요! 😆이렇게 NestJS에서 로거를 사용하여 앱을 더 안정적이고 재미있게 만들 수 있습니다. 개발하면서 로그를 잘 활용해 보세요!" }, { "title": "React의 Children API로 놀아보자!", "url": "/posts/React%EC%9D%98-Children-API%EB%A1%9C-%EB%86%80%EC%95%84%EB%B3%B4%EC%9E%90!/", "categories": "JavaScript", "tags": "React, ChildrenAPI", "date": "2023-06-06 20:00:00 +0900", "snippet": "안녕하세요 여러분! 오늘은 여러분과 함께 React의 Children API를 탐험할 예정이에요! 들어가기 전에, Children API는 무엇인지, 왜 필요한지 한번 간단히 알아볼까요? 🤔Children API가 뭐에요?자, 여러분! React에서 Children라는 이름을 들어본 적이 있나요? 아니요? 그럼 오늘 처음 들어볼 날이네요! 😊Children API는 React에서 children prop을 다루기 위한 특별한 도구입니다. Children과 children, 두 친구는 조금 다른데요. 소문자로 시작하는 ‘children’은 컴포넌트의 자식 요소들을 나타내며, 대문자로 시작하는 ‘Children’은 그 자식 요소들을 더 잘 다루기 위한 API랍니다!Children API를 통해서 children prop을 좀 더 안전하고 효과적으로 다룰 수 있답니다. 어떻게 사용하는지 함께 알아볼까요? 😁어떻게 접근하나요?자, 첫 번째 방법은 React 패키지에서 React.Children로 접근하는 것이에요! 이렇게 사용해볼 수 있답니다.import React from \"react\";function ReactChildren({ children }) { console.log(React.Children); return &lt;&gt;ReactChildren&lt;/&gt;;}두 번째 방법은 Children을 바로 불러와서 사용하는 거에요! 이렇게요:import { Children } from \"react\";function ReactChildren({ children }) { console.log(Children); return &lt;&gt;ReactChildren&lt;/&gt;;}어떤 방법을 선택할지는 여러분의 선택이에요! 저는 개인적으로 첫 번째 방식을 선호하는데, 두 친구 ‘Children’과 ‘children’이 서로 너무 닮아서 헷갈리기 쉽거든요! 👀Children API의 주요 기능들Children API에는 여러 가지 기능들이 있는데, 그 중 몇 가지를 뽑아 소개해드릴게요! 😊Children.map()Children.map()는 아마도 가장 많이 사용되는 함수일 거에요. 배열의 map() 함수와 비슷하다고 생각하시면 돼요! 이 함수를 통해 자식 요소들 각각에 특별한 변화를 줄 수 있어요. 예를 들어, 다음과 같이 사용할 수 있어요:function Map({ children }) { return React.Children.map(children, (child, i) =&gt; i % 2 === 0 ? &lt;b&gt;{child}&lt;/b&gt; : &lt;u&gt;{child}&lt;/u&gt; );}여기서는 홀수 번째(짝수 인덱스) 자식의 글씨를 굵게 하고, 짝수 번째(홀수 인덱스) 자식에 밑줄을 그어줬어요! 이렇게 편리하게 사용할 수 있답니다! 😁이제 여러분도 Children API 마스터!이제 여러분도 Children API를 사용해서 멋진 React 프로젝트를 만들어 볼 차례에요! Children API를 사용하면 복잡하고 어려운 children prop을 쉽고 안전하게 다룰 수 있다는 걸 꼭 기억하세요!이제 함께 React의 세계로 뛰어들 준비가 되셨나요? 그럼, 함께 놀러가요~ 🚀" }, { "title": "React 체크박스로 놀아보자!", "url": "/posts/React-%EC%B2%B4%ED%81%AC%EB%B0%95%EC%8A%A4%EB%A1%9C-%EB%86%80%EC%95%84%EB%B3%B4%EC%9E%90!/", "categories": "JavaScript", "tags": "React, 체크박스", "date": "2023-06-04 20:00:00 +0900", "snippet": "안녕하세요 여러분! 오늘은 React 체크박스를 함께 알아보고, 신나게 놀아볼 거에요! ✨첫 번째 만남: 체크박스와 React 💫체크박스란, 그 이름 그대로 상자 안에 체크(✔️)를 해서 ‘이거다!’라고 선택해 주는 친구에요. HTML에서 &lt;input&gt; 요소의 type 속성을 checkbox로 설정하면, 간단하게 체크박스를 만날 수 있어요.React에서는 체크박스 컴포넌트를 만들어서 여러 군데에서 재활용 할 수 있는데요, 바로 함께 체크박스 컴포넌트를 만들어 볼게요!function Checkbox({ children, disabled, checked, onChange }) { return ( &lt;label&gt; &lt;input type=\"checkbox\" disabled={disabled} checked={checked} onChange={({ target: { checked } }) =&gt; onChange(checked)} /&gt; {children} &lt;/label&gt; );}이렇게 작성하면 체크박스 친구가 탄생해요! 🌱 children은 체크박스 옆에 따라다닐 설명 텍스트를 의미하고, disabled는 체크박스를 사용할 수 없게 만드는 스위치 역할이에요. 또, checked와 onChange는 체크의 상태를 관리해 줘요!체크박스와 함께 하는 회원 가입 파티 🎉자, 이제 체크박스를 회원 가입 폼에 활용해 볼 거에요. “서비스 이용약관”과 “마케팅 수신”에 대한 동의를 받을 때 체크박스가 큰 역할을 해줄 거에요!function App() { const [service, setService] = React.useState(false); const [marketing, setMarketing] = React.useState(false); return ( &lt;article&gt; &lt;header&gt; &lt;h3&gt;체크박스&lt;/h3&gt; &lt;/header&gt; &lt;Checkbox checked={service} onChange={setService}&gt; (필수) 서비스 이용약관 &lt;/Checkbox&gt; &lt;Checkbox checked={marketing} onChange={setMarketing}&gt; (선택) 마케팅 수신 &lt;/Checkbox&gt; &lt;footer&gt; &lt;button disabled={!service}&gt;회원 가입&lt;/button&gt; &lt;/footer&gt; &lt;/article&gt; );}이렇게 작성하면 체크박스를 사용한 회원 가입 폼이 완성되요! 🎊체크박스의 팀플레이: CheckboxGroup 🤝체크박스도 혼자 있으면 쓸쓸하죠. 여러 개의 체크박스가 모여 팀을 이루면 더 좋아요. 그래서 CheckboxGroup이라는 컴포넌트를 만들어 볼게요!import CheckboxContext from \"./CheckboxContext\";function CheckboxGroup({ label, children, disabled: groupDisabled, values, onChange }) { const isDisabled = (disabled) =&gt; disabled || groupDisabled; const isChecked = (value) =&gt; values.includes(value); const toggleValue = ({ checked, value }) =&gt; { if (checked) { onChange(values.concat(value)); } else { onChange(values.filter((v) =&gt; v !== value)); } }; return ( &lt;fieldset&gt; &lt;legend&gt;{label}&lt;/legend&gt; &lt;CheckboxContext.Provider value=&gt; {children} &lt;/CheckboxContext.Provider&gt; &lt;/fieldset&gt; );}CheckboxGroup은 여러 개의 체크박스를 하나의 팀으로 묶어서 관리할 수 있게 해줘요. fieldset과 legend를 이용해서 체크박스 그룹을 표시해 주고, CheckboxContext.Provider를 통해 체크박스들에게 필요한 정보를 제공해 주어요!마치며 🌈오늘은 체크박스와 함께 React에서의 활용 방법을 알아보았어요! 여러분도 체크박스를 활용해서 멋진 작업을 해보세요! 그럼 즐거운 코딩 되세요!😊" }, { "title": "건강한 NestJS 서비스를 만드는 방법!", "url": "/posts/%EA%B1%B4%EA%B0%95%ED%95%9C-NestJS-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95!/", "categories": "JavaScript", "tags": "NextJS, NextJS서비스", "date": "2023-06-03 20:00:00 +0900", "snippet": "안녕하세요 여러분! 🌟 오늘은 단순하지만 굉장히 중요한 주제를 다루러 왔습니다. 바로 NestJS 앱에서 건강 검사를 어떻게 하는지 알아보는 거에요. 함께 해보실래요? 😊마이크로서비스 아키텍처의 주요 관리자가 되어보자! 🚀우리가 만드는 앱이 잘 작동하고 있는지, 또는 서비스가 준비되어 있는지 확인하는 것은 굉장히 중요한 일이죠. 이러한 걸 확인하는 역할을 하는 것이 바로 엔드포인트(endpoint) 라는 친구인데요, 이 친구를 통해 서비스의 생존 여부(liveness)와 가용 여부(readiness)를 확인할 수 있어요!그럼 바로 이 엔드포인트를 어떻게 만드는지 한번 보러 가볼까요? 😃새로운 프로젝트, 새로운 시작! 🎈NestJS 프로젝트를 만들려면 터미널에서 아래 명령어를 실행해야 해요! 그럼 새로운 프로젝트가 탄생하겠죠? 🐣$ nest new our-nestjs빠르게 확인하는 liveness 엔드포인트 만들기! ⚡이제 liveness 엔드포인트를 만들어 볼 거에요. 이 친구는 서비스가 ‘살아있는지’ 를 빠르게 확인할 수 있게 해줘요! 😊먼저 health 모듈과 health 컨트롤러를 만들어야겠죠? 아래 명령어로 둘 다 만들어 봅시다!$ nest generate module health$ nest generate controller health이제 기본적인 준비는 끝났어요! 컨트롤러에서 /health로 들어오는 요청을 처리하도록 코드를 작성해볼까요?import { Controller, Get } from \"@nestjs/common\";@Controller()export class HealthController { @Get(\"health\") checkHealth() { return \"OK\"; }}찰지게 만드는 readiness 엔드포인트! 💪이번에는 readiness 엔드포인트를 만들 차례에요! 이 친구는 서비스가 요청을 잘 처리할 수 있는 상태인지 확인해준답니다. NestJS에서는 이 엔드포인트를 만들기 위해 @nestjs/terminus라는 패키지를 제공해요! 😄$ npm i @nestjs/terminus패키지를 설치한 후, 아래와 같이 코드를 작성해서 힙 메모리 사용량이 300MB가 넘는지 확인하는 엔드포인트를 만들어 보겠습니다!import { Controller, Get } from \"@nestjs/common\";import { HealthCheck, HealthCheckService, MemoryHealthIndicator } from \"@nestjs/terminus\";@Controller()export class HealthController { constructor( private readonly health: HealthCheckService, private readonly memory: MemoryHealthIndicator ) {} @Get(\"health\") checkHealth() { return \"OK\"; } @Get(\"status\") @HealthCheck() checkStatus() { return this.health.check([ () =&gt; this.memory.checkHeap(\"memory_heap\", 300 * 1024 * 1024), ]); }}이제 서비스의 건강 상태를 확인하는 엔드포인트가 준비됐어요! 🎉 터미널에서 curl 명령어를 이용해 작성한 엔드포인트를 호출하면, 건강 상태를 확인할 수 있답니다! 😄마무리 🎁오늘은 NestJS 앱에서 중요한 건강 검사 엔드포인트를 만들어 보았어요! 이제 우리의 앱이 얼마나 건강한지 확인할 수 있겠죠? 🥰어려운 부분이 있으시다면 언제든지 댓글로 질문해주세요! 다음에 또 만나요! 🌈" }, { "title": "Prisma를 알아보자구요!", "url": "/posts/Prisma%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90%EA%B5%AC%EC%9A%94!/", "categories": "JavaScript", "tags": "Prisma", "date": "2023-06-02 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 🌈 오늘은 개발자들 사이에서 화제가 되고 있는 Prisma라는 녀석에 대해 함께 알아보려고 해요. 이 녀석이 뭐라고 이렇게 주목받고 있는지, 어떻게 사용하는지 쉽고 재미있게 알려드릴게요!Prisma의 매력은 무엇일까요? 🌠우선, Prisma는 자바스크립트와 타입스크립트의 ORM(Object Relational Mapping) 프레임워크로 알려져 있어요. ORM이라는 것은 데이터베이스와 앱 사이에서 데이터를 교환할 때 필요한 코드를 줄여주는 도구라고 생각하시면 돼요! 😄Prisma는 기존의 ORM 도구들과 달리 자체적인 스키마 문법을 제공해서, 데이터 모델링을 더 쉽고 효율적으로 할 수 있게 해주는 슈퍼 히어로 같은 녀석이에요. 덕분에 데이터베이스 관리가 훨씬 쉬워지구요!시작은 CLI 설치로! ⚙️그럼 Prisma의 세계로 한 발짝 더 들어가볼까요? 우리가 먼저 해야 할 일은 Prisma CLI(Command Line Interface)를 설치하는 것이에요. CLI는 터미널에서 사용할 수 있는 명령어들을 말해요. 다음과 같이 입력하면 CLI 설치가 시작돼요:$ npm i -D prisma설치가 끝나면, npx prisma라는 매직 스펠을 터미널에 입력해보세요. 이렇게 하면 Prisma와 관련된 다양한 명령어들과 그 설명들을 볼 수 있어요!Prisma 프로젝트 만들기 🎪이제 Prisma 프로젝트를 만들 차례에요! Prisma CLI를 통해 새 프로젝트를 만들어 볼 거에요. 터미널에 다음 명령어를 입력해주세요:$ npx prisma init --datasource-provider sqlite이 명령어로 Prisma 프로젝트가 생성되면서, “prisma”라는 이름의 폴더와 그 안에 “schema.prisma”라는 파일이 생기게 돼요. 어렵게 느껴질 수도 있는데, 걱정하지 마세요! 함께 천천히 알아보아요 😊스키마 작성하기 🎨이제 가장 중요한 부분인 스키마를 작성할 시간이에요! 스키마를 작성한다는 것은 우리가 만들 데이터베이스의 구조를 그리는 것이에요. 아래와 같이 간단한 User 모델을 만들어볼게요.model User { id Int @id @default(autoincrement()) email String @unique name String}여기서 @id는 아이디를 나타내고, @unique는 이메일이 유일해야 함을 나타내는 마술같은 기호에요! 😮와~ 여러분, Prisma의 기초적인 부분을 살펴보았어요! Prisma는 정말 다양한 기능을 제공하니, 꼭 한번 사용해 보시길 추천드려요. 여러분의 개발 여정에 작은 도움이 되었으면 좋겠어요!다음 시간에 또 뵙겠습니다, 안녕~ 👋😄" }, { "title": "NestJS 환경 설정 마스터 클래스", "url": "/posts/NestJS-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4/", "categories": "JavaScript", "tags": "NextJS, 환경설정", "date": "2023-06-01 20:00:00 +0900", "snippet": "배경지식 획득부터 시작해봅시다! 🎓여러분, 어느 날 갑자기 앱을 만들기로 결정했다고 생각해보세요. 근데 앱을 만들면서 환경 설정은 어떻게 해야할까요? 더 나아가서 NestJS를 이용하면 어떤 게 좋을까요? 걱정 마세요, 여러분을 위해 알차고 재미있는 길을 안내할게요! 🛣️앱을 만들며 첫 걸음마 뗀다면 🏃우선, NestJS 프로젝트를 하나 만들어보세요. NestJS CLI 도구의 ‘nest new’ 명령어를 사용하면 신나게 프로젝트를 시작할 수 있어요!$ nest new our-nestjs명령어를 입력하면 마법처럼 새 프로젝트가 생성된답니다! 🪄설정 지원 특급 패키지 @nestjs/config 📦아니면 설정을 조금 더 쉽게 관리하고 싶으신가요? 그러면 @nestjs/config 패키지를 꼭 설치하세요!$ npm i @nestjs/config이 친구는 여러분의 NestJS 프로젝트를 위한 설정 관리 전문가답니다!설정의 핵심은 바로 여기에! 🎯자, 이제 최상위 앱 모듈에서 ConfigModule을 불러와 설정해볼 차례에요. 어떻게 해야 할까요? 간단하게 코드 한 줄만 추가하면 돼요!ConfigModule.forRoot({ cache: true, isGlobal: true, })자, 이제 .env 파일이나 운영체제 수준에서 설정된 환경 변수를 바로 가져올 수 있게 됐어요! 어떤가요, 간단하죠? 🎉ConfigService의 활용 - 쉽고 재미있게! 😆이제 ConfigService를 통해 환경 변수에 접근할 시간이에요! 어떻게 하면 좋을까요? 먼저, 환경 변수 이름을 get() 메서드에 넘겨주면 그 값이 나오는 신기한 마법이 일어납니다! 🪄const host = this.configService.get&lt;string&gt;(\"HOST\");const port = this.configService.get&lt;number&gt;(\"PORT\", 3000);이렇게 하면, 환경 변수의 값들을 담은 JSON을 쉽게 가져올 수 있어요!설정 파일로 관리하는 방법도 있다구요! 📁환경 변수를 별도의 설정 파일에 저장해 관리하는 것도 괜찮은 아이디어에요! 설정과 관련된 값들을 객체로 반환하는 함수를 작성해서 관리할 수 있어요. 이렇게 하면 어떤가요?export default () =&gt; ({ app: { host: process.env.HOST || \"localhost\", port: parseInt(process.env.PORT, 10) || 3000, }, db: { host: process.env.DB_HOST || \"127.0.0.1\", port: parseInt(process.env.DB_PORT, 10) || 5432, },});이제 여러분도 환경 설정의 마스터가 됐어요! 그럼, 즐겁게 코딩하세요! 🚀" }, { "title": "JWT 토큰을 주고받기 길어지는 관계를 토큰 하나로!", "url": "/posts/JWT-%ED%86%A0%ED%81%B0%EC%9D%84-%EC%A3%BC%EA%B3%A0%EB%B0%9B%EA%B8%B0-%EA%B8%B8%EC%96%B4%EC%A7%80%EB%8A%94-%EA%B4%80%EA%B3%84%EB%A5%BC-%ED%86%A0%ED%81%B0-%ED%95%98%EB%82%98%EB%A1%9C!/", "categories": "JavaScript", "tags": "JWT토큰", "date": "2023-05-31 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 저와 함께 JWT 토큰의 세계로 빠져볼까요? 오늘은 토큰을 만들고, 검증하는 과정을 차근차근 살펴보겠습니다. 고고씽! 💫JWT 토큰, 그게 뭐에요? 🤔JWT는 JSON Web Token의 줄임말로, 장난꾸러기 같은 긴 문자열이에요. 이 문자열은 서버와 클라이언트가 정보를 안전하게 주고받을 수 있게 해줍니다. 마치 특별한 비밀 열쇠처럼, 이 토큰만 있으면 서버의 세상에 들어갈 수 있어요! ✨그럼, 이 열쇠는 어떻게 생겼을까요? 자, 지금부터 함께 만들어 볼까요?토큰 만들기, 우리만의 비밀 열쇠! 🗝️먼저, jsonwebtoken 패키지를 설치하겠습니다. 설치 마법 주문은 이렇게 외쳐주세요:npm install jsonwebtoken마법 주문을 외치면, 이제 우리만의 토큰을 만들 준비가 다 됐습니다! sign 함수를 사용해서 비밀 열쇠를 만들어볼게요. 이메일 정보를 담은 토큰을 만들어보겠습니다:const jwt = require('jsonwebtoken');const token = jwt.sign({ email: \"test@user.com\" }, \"our_secret\");console.log(token);이렇게 하면, 우리만의 특별한 토큰이 탄생합니다! 🌟물론, 우리만 알 수 있는 비밀번호도 넣어줘야 해요. 이 비밀번호가 바로 \"our_secret\"이랍니다! 나중에 토큰을 검증할 때 이 비밀번호가 필요해요.토큰 검증하기, 진짜 너 맞아? 🕵️우리가 만든 토큰을 가지고, 이제 클라이언트는 서버에게 자신을 인증해야 해요. 이 때 사용하는 함수가 바로 verify 함수입니다! 빙고!const verified = jwt.verify(token, \"our_secret\");console.log(verified);이제 우리는 토큰이 정말 우리가 만든 건지 확인할 수 있어요. 만약 토큰이 맞다면, 우리가 넣었던 데이터가 나타날 거예요!여러분이 배운 내용을 복습해 볼까요? JWT 토큰: 서버와 클라이언트가 안전하게 정보를 주고 받을 수 있는 방법 토큰 생성: sign 함수를 사용해 토큰을 생성 토큰 검증: verify 함수를 사용해 토큰을 검증지금까지 JWT 토큰의 세계를 여행했습니다! 재미있으셨나요? 🎢 다음에 또 만나요!" }, { "title": "Bearer 토큰과 Passport.js로 떠나는 코드 여행", "url": "/posts/Bearer-%ED%86%A0%ED%81%B0%EA%B3%BC-Passport.js%EB%A1%9C-%EB%96%A0%EB%82%98%EB%8A%94-%EC%BD%94%EB%93%9C-%EC%97%AC%ED%96%89/", "categories": "JavaScript", "tags": "토큰, PassportJS", "date": "2023-05-30 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 우리 함께 Passport.js라는 자바스크립트 프레임워크를 이용해서 Bearer 토큰 기반 API 인증을 만들어 볼거에요. 좌석을 뒤로 잘 누르시고 안전벨트를 매세요! 여행을 떠나 봅시다. 🚀비행 전 사전 준비 🛫우선, 무거운 짐을 줄이기 위해서 Express.js 패키지를 설치해야 해요. npm을 이용해서 깔끔하게 설치를 해 볼까요? 콘솔에 다음과 같이 입력해주세요!$ npm install express좋아요, 이제 비행기(서버 앱)를 만들 차례에요! 하지만 이 비행기는 매우 특별해요. GET 요청이 오면 ‘Hello, World!’라고 대답하는 비행기에요! 😄 아래 코드를 확인해봅시다.import express from \"express\";const app = express();app.get(\"/\", (req, res) =&gt; { res.send(\"Hello, World!\");});app.listen(3000, () =&gt; { console.log(\"Server is listening on port 3000\");});Passport.js와 함께하는 특별한 여행 🌄여기서 여행이 더 특별해지는 순간이에요! Passport.js를 설치해서 Bearer 토큰 기반 인증을 준비할 거에요. Passport.js는 우리에게 너무도 편리하게 인증 전략을 제공해요.$ npm i passport passport-http-bearer이제 비밀번호 같은 인증 토큰을 받아 볼 차례에요! 이 토큰을 사용해서 우리만의 비밀 클럽에 들어갈 수 있는 문을 만들어 봅시다!import passport from \"passport\";import BearerStrategy from \"passport-http-bearer\";passport.use( new BearerStrategy((token, done) =&gt; { if (token === \"1234\") { done(null, { email: \"user@test.com\" }); } else { done(null, false); } }));“1234”라는 비밀번호를 알고 있는 사람만 우리 비밀 클럽에 들어올 수 있어요! 😎 (실제로 이 비밀번호는 너무나도 간단해서 사용하면 안돼요! 😅)마지막 관문을 통과하자! 🚪이제 마지막으로, 우리만의 비밀 클럽에 들어올 수 있는 문을 만들 차례에요. 이 문은 유효한 Bearer 토큰이 있는 사람만 통과시켜줘요! passport.authenticate() 함수를 이용해서 마법의 문을 만들어 볼까요?app.get( \"/secret\", passport.authenticate(\"bearer\", { session: false }), (req, res) =&gt; { res.send(\"Welcome to the secret club! 🥳\"); });어때요? 이제 우리만의 비밀 클럽이 완성되었어요! 🎉 ‘1234’라는 특별한 토큰을 가지고 /secret 경로로 오면, 비밀 클럽에 들어올 수 있어요!이렇게 Passport.js와 Bearer 토큰을 이용하여 특별한 여행을 떠나봤어요. 비록 간단한 여행이었지만, 재미있으셨죠? 실제 애플리케이션에서는 이 방법을 더 발전시켜서 더욱 튼튼한 보안 시스템을 만들 수 있어요!다음 여행에서 또 만나요! 안녕! 👋" }, { "title": "NestJS 테스트로 뿌셔뿌셔!", "url": "/posts/NestJS-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A1%9C-%EB%BF%8C%EC%85%94%EB%BF%8C%EC%85%94!/", "categories": "JavaScript", "tags": "NextJS", "date": "2023-05-29 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 🦸 오늘은 NestJS API를 견고하게 만들어 줄 Jest와 Supertest를 함께 배워볼 거예요. 흔히 말하는 ‘깐깐한 테스터’가 되어 볼 시간이에요!💪 힘세고 강한 API 만들기 시작하기첫 번째 단계에서는 NestJS 프로젝트를 만들어 볼 거예요. 빨간망토를 걸치고 터미널로 직행! NestJS CLI 도구로 새로운 프로젝트를 만들어 보세요. 😊$ nest new our-nestjs이렇게 해서 우리만의 NestJS 프로젝트가 탄생했어요! 💖🧙‍♂️ 코드 마법사가 되어보자!다음으로, 우리는 코드 마법사가 되어, 약간의 코드를 바꿔 볼 거에요. app.controller.ts와 app.service.ts에 있는 코드를 살짝 변화시켜 볼까요? 🧙‍♂️// src/app.controller.ts@Controller()export class AppController { constructor(private readonly appService: AppService) {} @Get('hello') hello(@Query('name') name: string = 'World') { return { message: this.appService.getHello(name) }; }}🧰 필요한 도구 설치하기지금부터는 API 테스팅을 위한 필요한 도구들을 설치할 거에요. 터미널에서 아래와 같이 명령어를 입력해주세요! 🛠️$ npm i -D @nestjs/testing @types/supertest supertest😎 단위 테스트 작성하기이제 테스트 코드 작성을 위한 준비를 끝냈으니, 본격적으로 단위 테스트를 작성해볼 거에요! ‘단위 테스트 마스터’가 되어 봅시다! 😎단위 테스트는 아래와 같이 src/app.controller.spec.ts에 작성할 거에요.// src/app.controller.spec.tsdescribe('AppController', () =&gt; { let controller; let service; beforeEach(async () =&gt; { let module = await Test.createTestingModule({ controllers: [AppController], providers: [AppService], }).compile(); controller = module.get(AppController); service = module.get(AppService); }); describe('hello', () =&gt; { it('returns a default message', () =&gt; { jest.spyOn(service, 'getHello').mockReturnValue('Hey~'); expect(controller.hello()).toEqual({ message: 'Hey~' }); }); it('returns a personalize message', () =&gt; { jest.spyOn(service, 'getHello').mockReturnValue('Hey, John~'); expect(controller.hello('John')).toEqual({ message: 'Hey, John~' }); }); });});이렇게 코드를 작성하면 단위 테스트가 준비 완료된 것이에요! 👏🎉 테스트 축제 열기이제 테스트를 실행해 볼 거에요. 터미널에서 아래 명령어를 입력하면, 테스트 결과를 볼 수 있어요! 🎉$ npm test app.controller모든 테스트가 통과되면, 우리는 성공적으로 NestJS 테스트에 입문한 것이에요! 🌟어떠셨나요, 여러분? 오늘 함께 배운 내용으로 NestJS API를 더욱 견고하게 만들 수 있어요. 이제 NestJS 테스트 마스터가 되어, 멋진 API를 만들어 보세요! 💪" }, { "title": "NanoID 빠르고 깜찍한 고유 식별자 만들기", "url": "/posts/NanoID-%EB%B9%A0%EB%A5%B4%EA%B3%A0-%EA%B9%9C%EC%B0%8D%ED%95%9C-%EA%B3%A0%EC%9C%A0-%EC%8B%9D%EB%B3%84%EC%9E%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "JavaScript", "tags": "NanoID", "date": "2023-05-28 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 😊 오늘은 개발자들 사이에서 핫한 이슈가 되고 있는 NanoID에 대해 이야기해 볼까 해요. 기존에 사용하던 UUID가 있었지만, 이제는 더 작고 더 빠른 NanoID 시대가 열렸답니다! 자, 그럼 함께 둘러보아요!NanoID와 그 친구 UUID의 첫만남 🤝길었던 UUID 시절을 뒤로하고, 더 빠른 고유 식별자의 새 시대를 맞이하려 합니다. 우리 친구 NanoID는 21바이트라는 작은 크기로 UUID보다 경제적이에요. 그리고 가볍기까지 해서 많은 프로젝트에서 사랑받고 있답니다! 🎉NanoID는 여러 언어로 라이브러리 패키지가 제공되어, 손쉽게 설치하여 사용할 수 있어요.나만의 NanoID 만들기 🛠️자, 이제 기본 사용법을 배워볼 시간이에요! 먼저 npm을 통해 nanoid 패키지를 설치하고, 함수를 불러와 호출하면 끝! 아주 간단하지 않나요? 😁import { nanoid } from \"nanoid\"; const id = nanoid();console.log(id);그럼 이렇게 생성된 랜덤 문자열을 고유 식별자로 사용할 수 있답니다.나만의 스타일로 꾸미기 🎨NanoID는 다양한 옵션을 제공하여, 사용자가 원하는 대로 설정할 수 있어요. 길이 변경도, 알파벳 설정도 마음대로! 심지어 커스텀 알파벳을 설정하는 것도 가능하답니다.import { customAlphabet } from \"nanoid\";const nanoid = customAlphabet(\"0123456789ABCDEF\", 8);const id = nanoid();console.log(id);하지만 주의해야 할 점은, 식별자의 길이를 줄이면 충돌 위험이 증가한다는 거에요. 그러니까 꼭 신중하게 결정하시길 바랍니다!결론: NanoID로 행복하게 🎊자, 이렇게 함께 NanoID의 매력을 알아보았어요. 이제 여러분도 NanoID를 활용해서 더욱 안전하고 신뢰할 수 있는 고유 식별자를 만들 수 있게 되었네요! 🥳" }, { "title": "타입스크립트 비밀리에 숨겨진 버그를 잡아내는 마법사, TS-Reset", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%B9%84%EB%B0%80%EB%A6%AC%EC%97%90-%EC%88%A8%EA%B2%A8%EC%A7%84-%EB%B2%84%EA%B7%B8%EB%A5%BC-%EC%9E%A1%EC%95%84%EB%82%B4%EB%8A%94-%EB%A7%88%EB%B2%95%EC%82%AC,-TS-Reset/", "categories": "JavaScript", "tags": "타입스크립트, TS-Reset", "date": "2023-05-27 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 🚀 오늘은 개발자들 사이에서 수근수근 전해지는 타입스크립트의 비밀을 함께 풀어보는 시간을 가질거에요. “타입스크립트라니, 그게 뭐야?”라고 생각하는 분들도 있을 텐데요. 간단하게 설명하면, 타입스크립트는 자바스크립트의 특별한 형태로, 더 안정적인 코드를 작성하게 도와주는 도구에요. 🛠️타입스크립트의 눈물겨운 버그 이야기 🐜우리가 모르는 사이에 타입스크립트는 숨은 버그들로 눈물을 흘리고 있어요. 이제 그 눈물겨운 버그 이야기를 함께 들어볼까요?배열의 includes() 함수와 숨바꼭질 🙈개발자들이 배열에 특정 요소가 있는지 확인하려고 includes() 함수를 사용할 때, 황당한 상황에 봉착하게 됩니다. 읽기 전용으로 설정된 배열에서 이 함수를 사용하면, 타입스크립트는 그저 손을 흔들며 “이거 아니야!”라고 말해버리죠. 😅하지만 걱정 마세요! ts-reset라는 라이브러리를 사용하면 이 문제를 아주 깔끔하게 해결할 수 있어요.const numbers = [1, 2, 3] as const;numbers.includes(4); // 🎉 false타입스크립트, indexOf()와 lastIndexOf()에서의 적반하장 😜indexOf()와 lastIndexOf() 함수도 비슷한 문제에 봉착해요. 정말로 없는 값을 찾으라고 요청하면 타입스크립트는 눈을 깜짝할 새에 에러 메시지를 보여줘요.하지만 ts-reset라는 마법사가 다시 한번 우리를 구해줘요! 🧙const numbers = [1, 2, 3] as const;numbers.indexOf(4); // 🙃 없어요! 에러 없이 잘 작동해요!filter() 함수의 깜짝 파티 🎉마지막으로, filter() 함수도 이상한 점이 한두 가지가 아니에요. undefined나 null 값을 걸러내려고 할 때 타입스크립트는 마치 우리를 테스트하는 것 마냥, “이렇게도 할 수 있고, 저렇게도 할 수 있다구!”라며 다양한 방법을 제시해요. 😆const tags = [\"work\", \"life\", undefined, \"travel\", null];const validTags = tags.filter((tag): tag is string =&gt; !!tag); // [\"work\", \"life\", \"travel\"]하지만 ts-reset 라이브러리를 사용하면, 마치 눈앞에 무지개가 펼쳐지는 것 마냥, 우리는 아름다운 타입스크립트 세상에 입문하게 돼요. 🌈마치며타입스크립트의 세계는 버그와 싸우면서도 우리에게 더 나은 코딩 환경을 선사해요. 함께 타입스크립트의 세계를 더 깊게 탐험해봐요! 🚀" }, { "title": "자바스크립트의 매력적인 친구, 세트(Set)를 소개합니다!", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EB%A7%A4%EB%A0%A5%EC%A0%81%EC%9D%B8-%EC%B9%9C%EA%B5%AC,-%EC%84%B8%ED%8A%B8(Set)%EB%A5%BC-%EC%86%8C%EA%B0%9C%ED%95%A9%EB%8B%88%EB%8B%A4!/", "categories": "JavaScript", "tags": "자바스크립트, 세트, Set", "date": "2023-05-26 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 자바스크립트에서 중요한 역할을 하는 친구를 소개하고자 해요. 바로 세트(Set)입니다! 세트는 ES6에서 처음 만나게 된 친구인데요, 아직은 많이 모르는 친구랍니다. 놀라지 마세요, 이제부터 차근차근 세트의 매력을 알아보아요! 😄세트(Set)란 무엇일까요?세트는 우리가 수학 시간에 배웠던 그 집합과 비슷한 아이디어를 가지고 있어요. 순서가 없고 중복된 값이 없는 데이터의 집합이지요. 배열과 비슷하다고 느낄 수 있는데, 이 둘은 사실 완전히 다른 성격을 가진 친구들이에요.자바스크립트의 세트는 데이터를 순서없이 저장해요. 그래서 배열처럼 인덱스를 통해 접근할 수가 없어요. 또 한 가지 특징은 중복된 데이터를 허용하지 않는다는 거에요. 🚫 그래서 세트에 동일한 값을 여러 번 넣어도, 세트는 “아니야, 이미 있어!” 하며 거절합니다. 😅세트를 만들어 봅시다!자바스크립트에서는 new Set()으로 세트를 만들 수 있어요. 이렇게 하면 비어있는 세트가 생기지요. 😮 또한 배열을 인자로 넣어주면 배열의 요소들이 세트의 요소로 변환되어요.const numSet = new Set([1, 2, 3]); // Set(3) {1, 2, 3}세트에 값 추가하기이제 세트에 값을 추가해볼까요? add() 메서드를 사용해서 세트에 값을 추가할 수 있어요. 세트는 중복을 좋아하지 않으니까, 중복된 값은 받아주지 않아요! 🙅‍♂️set.add(1); // Set(1) {1}set.add(\"A\"); // Set(2) {1, 'A'}세트에서 값 삭제하기뭐든지 받아주는 세트가 아니니까요, 세트에서 값을 삭제할 때도 따로 메서드가 있어요. 바로 delete() 메서드에요.set.delete(1); // trueset.delete(2); // false삭제가 성공하면 true, 실패하면 false를 반환한다는 재미있는 성격을 가지고 있어요!세트와 친해지기자바스크립트의 세트는 우리의 코딩을 더 편리하게 만들어주는 친구에요. 이제부터 세트와 친하게 지내보도록 해요! 😊" }, { "title": "타입스크립트, 정말 모든 것을 다 해결해 줄 수 있을까요", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8,-%EC%A0%95%EB%A7%90-%EB%AA%A8%EB%93%A0-%EA%B2%83%EC%9D%84-%EB%8B%A4-%ED%95%B4%EA%B2%B0%ED%95%B4-%EC%A4%84-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94/", "categories": "JavaScript", "tags": "타입스크립트", "date": "2023-05-25 20:00:00 +0900", "snippet": "안녕하세요 여러분! 오늘은 개발자들 사이에서 뜨거운 감자로 떠오르고 있는 ‘타입스크립트’에 대해 이야기해 볼까 합니다. 종종 “타입스크립트를 사용하면 유효성 검증은 필요 없어?”라는 질문을 받곤 하는데요, 이 물음에 대한 답을 찾기 위해 오늘은 탐험가의 모험을 떠나 볼까 합니다! 🚀타입스크립트의 신비한 세계 🌍타입스크립트는 마치 우리가 탐험을 떠나기 전에 먼저 지도를 그리는 것과 같아요. 우리가 어떤 길을 가야 할지 미리 알려주죠. 이렇게 미리 길을 알려주면, 길을 잃거나 헤매이지 않고 편하게 여행을 할 수 있어요. 🗺️interface Account { id: string; email: string; age: number; level: \"GOLD\" | \"SILVER\" | \"BRONZE\"; active: boolean; createdAt: Date; image?: string | undefined; ips?: string[] | undefined;}function processAccount(account: Account) { // 로직 여기에 작성!}위의 코드는 우리가 떠나기 전에 그린 지도 같은 거예요. 여기서 어떤 데이터가 어떤 형태로 와야 할지 미리 정해놓았죠.오류 메시지, 나의 길잡이 ⭐하지만, 모험을 떠날 때 항상 기대한 대로 일이 흘러가지 않아요. 가끔은 예상치 못한 일들이 생기죠. 그럴 때 우리에게 길을 알려주는 ‘오류 메시지’가 나타나요!processAccount({}); // ❌ \"이봐요, 여기 정보가 부족해요!\"이 오류 메시지는 마치 길을 잃었을 때 나타나는 나침반 같은 것이에요. 나침반은 우리에게 다시 올바른 길을 찾아가도록 도와줍니다. 🧭타입스크립트, 현실에서는 힘이 없어요 💪그런데 타입스크립트는 현실 세계, 즉 실제로 코드가 실행되는 환경에서는 힘이 없어요. 실제 세계에 나가면 그때부터는 자바스크립트의 규칙이 적용되기 때문이죠. 그래서 아무리 타입스크립트에서 잘 정해놓았다 해도, 실제로 코드를 실행할 때는 자바스크립트의 세계에서 헤메일 수밖에 없어요. 😅function processAccount(account) { // 어떤 로직}updateAccount({}); // ✅ \"아무 문제 없어요, 뭐든지 할 수 있죠!\"이 때문에 미리 유효성 검증을 잘 해놓지 않으면, 코드가 실제로 실행될 때 문제가 생길 수 있어요. 그래서 유효성 검증은 꼭 필요하답니다! 🔍정리해 볼까요? 🎤타입스크립트는 마치 모험을 떠나기 전에 미리 준비하는 것과 같아요. 그러나 실제 모험을 떠날 때는 자바스크립트의 세계에서 노닥거리게 되죠. 그렇기 때문에 유효성 검증은 타입스크립트로 다 해결할 수 있는 문제가 아니랍니다. 두 가지는 서로 다르고, 각각의 역할이 있어요. 😊다음 모험에서 또 만나요, 모험가 여러분! 💖" }, { "title": "Zod로 간편하게 유효성 검증하기!", "url": "/posts/Zod%EB%A1%9C-%EA%B0%84%ED%8E%B8%ED%95%98%EA%B2%8C-%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%A6%9D%ED%95%98%EA%B8%B0!/", "categories": "JavaScript", "tags": "Zod, 유효성검증", "date": "2023-05-24 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 😊 오늘은 여러분들에게 최근 개발자들 사이에서 핫한 주제 중 하나인, Zod 라이브러리에 대해 이야기하려고 해요! 이 글을 통해 Zod의 세계로 함께 빠져보아요! 💫Zod 설치하기 🛠먼저, Zod를 사용하려면 npm으로 zod 패키지를 설치해야 해요! 😄 그리고 아주 꼭꼭 추천하고 싶은 건, 타입스크립트를 strict 모드로 사용하는 것이에요! 다음과 같이 설정할 수 있어요.{ \"compilerOptions\": { \"strict\": true }}스키마 정의하기 📝자, Zod의 첫걸음은 스키마를 정의하는 것이에요! 스키마란 간단하게 말해서 데이터의 형태와 구조를 말하는 거에요.이렇게 스키마를 정의하면, 데이터가 어떤 형태를 가져야 하는지를 쉽게 알 수 있어요. 그럼, 이메일, 나이, 활성화 여부로 이루어진 사용자 객체를 Zod로 정의해볼게요!const User = z.object({ email: z.string(), age: z.number(), active: z.boolean(),});유효성 검증 🧐이제 스키마를 만들었으니, 유효성 검증을 해볼 차례에요! 스키마의 parse() 함수에 검증하고 싶은 값을 넣어 호출하면 돼요.예를 들어, 아래와 같이 데이터를 검증할 수 있어요.User.parse({ email: \"user@test.com\", age: 35, active: true,}); // ✅ 유효성 검증 통과하지만 여기서 주의해야 할 점이 있어요! 만약 검증에 실패한다면 parse() 함수는 오류를 발생시켜요. 하지만 걱정마세요! 오류 메시지가 나와서 어디가 문제인지 쉽게 알 수 있어요! 😉타입 추론 🤓Zod의 마지막 매력 포인트는 바로 타입 추론 기능이에요! Zod 스키마를 기준으로 타입스크립트 타입을 자동으로 추론할 수 있어요. 이 기능 덕분에, 타입을 따로 작성할 필요가 없어지고, 스키마와 타입을 서로 맞춰줄 걱정도 사라져요. 꽤나 똑똑한 친구죠? 😄type UserType = z.infer&lt;typeof User&gt;;자, 이렇게 Zod의 기본적인 사용 방법을 쉽게 알아봤어요! 어때요, Zod는 정말 사용하기 쉽고 편리한 라이브러리죠? 여러분도 Zod를 사용해서 개발의 효율성을 높여보세요! 그럼, 코딩하는 즐거움이 두 배가 되길 바라며, 여기서 인사를 드리겠습니다! 😊" }, { "title": "Zod 스키마로 친근하게 배우는 타입스크립트", "url": "/posts/Zod-%EC%8A%A4%ED%82%A4%EB%A7%88%EB%A1%9C-%EC%B9%9C%EA%B7%BC%ED%95%98%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/", "categories": "JavaScript", "tags": "Zod스키마, 타입스크립트", "date": "2023-05-23 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 짜잔~ 우리 함께 타입스크립트의 세계를 Zod 스키마와 함께 탐험해볼 거에요. 뭔가 고급진 이름 같죠? 😅 걱정 마세요! 이 친구, 친절하고도 쉽게 우리에게 타입스크립트의 세계를 열어줄 거예요. 그럼 함께 뛰어보아요! 🏃‍♂️뭐부터 시작할까? 😮우리가 탐험을 시작하기 전에, 꼭 알아야 하는 것이 있어요. 그게 바로 “스키마 정의”랍니다. 이게 뭔지 궁금하시죠? 😏 스키마 정의는 자료형을 명시하는 것에서 시작해요. Zod는 우리에게 자바스크립트의 기본 자료형이나 Date와 같은 내장 클래스에 대응하는 검증자 함수를 제공해 준답니다!실제로 만들어보자! 💪자, 그럼 실제로 스키마를 만들어 볼 거에요. 우리는 이메일, 나이, 활성화 여부, 생성 일자라는 정보를 가진 사용자 객체 스키마를 만들어 볼 건데요. 아래와 같이 만들 수 있어요!import { z } from \"zod\";const User = z.object({ email: z.string(), age: z.number(), active: z.boolean(), createdAt: z.date(),});이렇게 하면 User 스키마가 만들어지는데, 각 속성들이 어떤 타입인지도 쉽게 알 수 있어요. 참 쉽죠? 😄필수 입력이 뭐에요? 🤔이제 필수 입력에 대해 배워볼 차례에요. 필수 입력은 말 그대로 꼭 입력해야 하는 정보랍니다. 하지만 Zod에서는 이를 선택 입력으로 바꿀 수 있어요! 어떻게 할까요? 바로 optional() 검증자를 사용하면 돼요. 아래와 같이 해볼까요?import { z } from \"zod\";const User = z.object({ email: z.string(), age: z.number(), active: z.boolean().optional(),});이제 active 속성이 선택 입력이 되었어요! 잘했어요! 👍기본값 설정도 가능해요! 🌟Zod 스키마에서 누락된 속성에 기본값을 설정할 수도 있어요. default() 검증자를 사용해서 active 속성이 누락되었을 때 false로 설정해볼까요?import { z } from \"zod\";const User = z.object({ email: z.string(), age: z.number(), active: z.boolean().default(false),});마지막으로 배열과 객체! 🎈배열과 객체 스키마도 만들 수 있어요. 아래와 같이 해볼까요?import { z } from \"zod\";const IPs = z.array(z.string());이제 배열 스키마도 만들었어요! 마지막으로 객체 스키마를 만들어 볼게요. z.record() 검증자를 사용해서 키 이름에 구애받지 않고 값만 타입을 제한할 수 있어요. 아래와 같이 해볼까요?import { z } from \"zod\";const NumberRecord = z.record(z.number());이렇게 하면, 숫자만 사용할 수 있는 객체에 대한 스키마를 만들 수 있어요! 멋지죠? 😎마무리 🌈우리가 함께 Zod 스키마로 타입스크립트의 세계를 탐험했어요! 어떠셨나요? 조금은 친숙해진 것 같죠? 😊Zod 스키마를 통해 타입스크립트를 배우는 것은 정말 쉽고 재미있어요. 다음에도 또 이렇게 함께 코딩 세계를 탐험하면 좋겠네요! 그럼, 다음에 또 만나요! 파이팅! 🌟" }, { "title": "Zod로 놀아보자!", "url": "/posts/Zod%EB%A1%9C-%EB%86%80%EC%95%84%EB%B3%B4%EC%9E%90!/", "categories": "JavaScript", "tags": "Zod", "date": "2023-05-22 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 Zod라는 놀이터에서 스키마를 만지작거리며 트랜스포머로 힘을 불어넣어 볼 거에요. 자, 손끝에 마법의 힘을 모으고 함께 Zod 세계로 떠나볼까요? ✨트랜스포머가 뭐에요? 🤔트랜스포머는 Zod의 특별한 마법 도구인데요, 데이터를 변형시키는 데 사용해요. 마치 누군가가 “안녕하세요!” 라고 외치면 그것을 “안녕!”이라고 바꿔주는 것처럼 말이죠! 🌈내장 트랜스포머로 노는 법Zod에는 몇 가지 특별한 마법이 미리 준비되어 있어요. .trim(), .toLowerCase(), .toUpperCase()라는 마법들이에요! 그럼 이제 이 마법들을 한번 사용해 볼까요? ✍️import { z } from \"zod\";const Transformers = z.object({ trimmed: z.string().trim(), lowerCased: z.string().toLowerCase(), upperCased: z.string().toUpperCase(),});const output = Transformers.parse({ trimmed: \" Hello, Zod! \", lowerCased: \"Hello, Zod!\", upperCased: \"Hello, Zod!\",});console.log(output);완성! ✨ 이제 “ Hello, Zod! “가 “Hello, Zod!”로 바뀌고, 모든 글자가 소문자 또는 대문자로 변형되는 마법을 볼 수 있어요!직접 트랜스포머 만들기 🧙‍♀️하지만 우리는 더 멋진 마법을 만들 수 있어요. 바로 자신만의 트랜스포머를 만드는 거에요! 이 마법은 입력을 숫자와 문자 둘 다 받을 수 있지만 출력은 무조건 문자로 바꾸는 거에요. 직접 마법을 만들어 볼까요? 😎import { z } from \"zod\";const ID = z .string() .or(z.number()) .transform((id) =&gt; (typeof id === \"number\" ? String(id) : id));const id = ID.parse(1);console.log(typeof id, id);와~ 숫자 1이 “1”로 바뀌었어요! 🎉 이 마법으로 문자와 숫자를 오가며 놀 수 있겠어요!더 복잡한 마법도 가능해요! 🎩Zod 마법은 더 복잡한 것도 가능해요! 여러 속성이 서로에게 영향을 주는 마법도 만들 수 있어요. 예를 들면, firstName과 lastName을 받아서 fullName을 만들어 내는 거죠! 한번 해볼까요? 🎨import { z } from \"zod\";const User = z .object({ firstName: z.string(), middleName: z.string().optional(), lastName: z.string(), }) .transform((user) =&gt; ({ ...user, fullName: user.middleName ? `${user.firstName} ${user.middleName} ${user.lastName}` : `${user.firstName} ${user.lastName}`, }));console.log(User.parse({ firstName: \"John\", lastName: \"Doe\" }));console.log(User.parse({ firstName: \"John\", middleName: \"K.\", lastName: \"Doe\" }));와~ 이제 John Doe 씨도 본인의 전체 이름을 소환할 수 있겠어요! 🥳마치며오늘은 Zod의 마법 세계에서 여러 가지 마법을 배웠어요. 스키마 마법사가 되어 더 멋진 마법을 만들어보세요! 🌈" }, { "title": "자바스크립트에서 스트림 만들기", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "JavaScript", "tags": "자바스크립트, 스트림", "date": "2023-05-21 20:00:00 +0900", "snippet": "안녕하세요, 자바스크립트로 스트림을 만드는 방법에 대해 쉽고 재미있게 알려드릴게요! 스트림이 뭐냐구요? 데이터를 연속적으로 처리할 수 있게 해주는 흐름이라고 생각하시면 돼요. 이제부터 같이 스트림을 만드는 방법에 대해 알아볼까요? 😀스트림 만들기의 첫걸음 🚀먼저, 자바스크립트에서 스트림을 만들려면 ReadableStream이라는 클래스를 사용해야 해요. 클래스라는 건 사실 어렵게 생각할 필요 없이, ‘물건을 만들어내는 공장’이라고 생각하시면 돼요!이 ‘공장’은 두 가지 재료를 받는데요, 우리는 첫 번째 재료인 underlyingSource만 사용할 거예요. 이건 스트림에서 데이터를 가져올 ‘원천지’라고 볼 수 있어요.const stream = new ReadableStream({ start(controller) { console.log(\"start\"); let num = 0; const interval = setInterval(() =&gt; { controller.enqueue(num++); if (num === 10) { controller.close(); clearInterval(interval); } }, 1_000); },});위 코드를 보면, 데이터를 공급하는 특별한 함수인 start() 함수가 있죠. 그 안에는 controller라는 것이 있는데, 이 친구가 데이터를 스트림에 집어넣어줘요. 데이터를 모두 넣었으면 controller.close()를 호출해서 데이터 공급을 멈춘답니다!스트림에서 데이터 읽기 📖데이터를 잘 만들었으니 이제 읽어볼 차례에요! 스트림에서 데이터를 읽으려면 getReader() 함수를 호출해서 ‘리더’를 만들어야 해요. 이 ‘리더’는 데이터를 읽는 역할을 해주는 친구라고 생각하시면 돼요!const reader = stream.getReader();reader.read().then(function print({ done, value }) { if (done) return console.log(\"done\"); console.log({ value }); reader.read().then(print);});여기서 보이는 read() 함수는 스트림에서 데이터를 읽어오는 역할을 해요. 이 함수를 호출하면, 데이터를 읽어오는 일이 시작되죠. 이렇게 읽어온 데이터는 value라는 곳에 저장되어, 우리가 확인할 수 있게 되요.그래서 위 코드를 실행하면, 1초 간격으로 숫자 데이터가 차례로 출력되는 걸 볼 수 있어요. 마지막에는 “done”이라고 나오면서 데이터 읽기가 끝나게 됩니다.맺음말 🎉자, 이제 자바스크립트로 스트림을 만들고 데이터를 읽는 방법을 알게 됐어요! 그리고 모든 이야기는 꼭 해피엔딩으로 끝나야죠. 우리도 “done”이라는 단어를 보며, 성공적으로 데이터 읽기 여정을 마무리 지을 수 있어요!즐거운 코딩 되세요! 😄" }, { "title": "Partytown 웹 워커의 즐거운 파티", "url": "/posts/Partytown-%EC%9B%B9-%EC%9B%8C%EC%BB%A4%EC%9D%98-%EC%A6%90%EA%B1%B0%EC%9A%B4-%ED%8C%8C%ED%8B%B0/", "categories": "JavaScript", "tags": "Partytown, 웹워커", "date": "2023-05-20 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 🎉 오늘은 웹 사이트를 더 빠르고 즐겁게 만들어주는 놀라운 라이브러리, Partytown에 대해 이야기하려고 합니다. 이 라이브러리는 마치 파티에서 특별한 손님이 도착한 것처럼, 웹 개발 세상에 새로운 활력을 불어넣어 줍니다. 그럼 파티의 별, Partytown을 함께 만나보실까요?왜 Partytown인가요? 🥳먼저, Partytown이라는 이름에서 느껴지는 즐거움이 무엇인지 알아보겠습니다. 이름에서도 알 수 있듯, 이 라이브러리는 서드파티(3rd-party) 스크립트 로딩을 위한 파티의 주인공이에요. 그리고 그 이름에는 ‘즐거운 파티’의 뜻도 담겨 있어, 웹사이트 개발이라는 일을 더 즐겁게 만들어줄 것 같은 기대감을 느낄 수 있어요. 🎈웹 워커: 웹 세상의 슈퍼히어로 🦸웹 워커는 마치 슈퍼히어로처럼 웹 개발 세계에 등장했어요! 웹 워커는 웹사이트의 백그라운드에서 메인 쓰레드와 별개로 동작하는 쓰레드로, 웹사이트의 성능을 획기적으로 향상시켜줄 수 있답니다. 😎웹 워커를 활용하면, 기존에 웹에서 불가능했던 동시성 프로그래밍을 실현할 수 있게 돼요. 이제 웹사이트를 더 빠르게, 더 효율적으로 만들 수 있는 시대가 열린 것이죠. 🚀Partytown과 웹 워커의 만남 🕺💃이제 Partytown이 웹 워커를 어떻게 활용하는지 살펴볼 차례에요! Partytown은 웹 워커 쓰레드를 이용하여 서드파티 스크립트를 백그라운드에서 빠르게 로딩해준답니다. 그 결과, 웹사이트 성능과 사용자 경험이 획기적으로 개선되는 것이죠. 🌟당신의 웹사이트도 Partytown의 힘을 빌려, 사용자에게 더 빠른 서비스를 제공해보세요!Partytown 설치하기: 초대장 받기 💌Partytown은 쉽게 설치할 수 있는 npm 패키지로 제공되고 있어요. npm 패키지 매니저를 통해서 아래와 같이 쉽게 설치할 수 있답니다.$ npm i @builder.io/partytown이제 Partytown의 초대장을 받으셨습니다! 웹사이트 개발 파티에 참석해서 빠른 로딩 속도의 장점을 만끽해보세요! 🎊마무리: Partytown으로 즐거운 개발 시작하기 🎉이제 Partytown 라이브러리를 통해 웹사이트 성능을 한 단계 업그레이드 시킬 준비가 다 되었네요! Partytown으로 웹 워커의 힘을 빌리면, 당신의 웹사이트도 훨씬 더 빠르고, 사용자 경험이 풍부해질 거에요.웹 개발자들이여, Partytown과 함께 즐거운 개발의 세계로 떠나보세요! 🎉" }, { "title": "NestJS 가드 초보자를 위한 무장 튜토리얼", "url": "/posts/NestJS-%EA%B0%80%EB%93%9C-%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%AC%B4%EC%9E%A5-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/", "categories": "JavaScript", "tags": "NextJS, NextJS가드", "date": "2023-05-19 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 😊 오늘은 우리가 만들 게임의 보안 경비병이 되어볼까요? 어떻게 하면 NestJS 애플리케이션을 더 안전하게 지킬 수 있는지 알아봅시다!NestJS 가드란 무엇인가요? 🤔우리 NestJS 애플리케이션은 정말 멋진 성이에요. 그런데, 이 멋진 성을 지키기 위해 경비병이 필요하죠. NestJS에서 경비병 역할을 하는 것이 바로 ‘가드(Guard)’에요! 🛡️ 가드는 애플리케이션의 대문을 지키며, 안전하지 않은 요청들을 걸러줍니다. 그래서, 안전하고 편안한 성 안에서 우리는 게임을 즐길 수 있어요! 😉가드를 만들어 보자! 🧑‍🚀그러면 우리도 한 번 가드를 만들어보는 시간을 가져볼까요? 🤗 가장 먼저 해야 할 일은 가드를 만드는 재료인 @nestjs/common 모듈에서 CanActivate 인터페이스를 불러오는 거에요.import { Injectable, CanActivate } from '@nestjs/common';@Injectable()export class AuthGuard implements CanActivate { canActivate() { console.log('인증이 성공하였습니다.'); return true; }}이 코드를 보면, canActivate 메서드가 있는 걸 볼 수 있어요. 이 메서드가 가드의 심장이라고 할 수 있는데, 여기서 우리가 어떤 요청을 허용할지, 막을지 결정을 해요! 😊컨트롤러에 가드 적용하기 🎯이제 우리가 만든 가드를 애플리케이션에 적용시켜 볼 시간이에요! @UseGuards 데코레이터를 사용해서 우리가 만든 AuthGuard를 컨트롤러에 붙여줍니다.import { Controller, Get, UseGuards } from '@nestjs/common';import { AppService } from './app.service';import { AuthGuard } from './auth.guard';@UseGuards(AuthGuard)@Controller()export class AppController { constructor(private readonly appService: AppService) {} @Get() getHello(): string { return this.appService.getHello(); }}이제 컨트롤러가 우리의 가드에 잘 보호받고 있어요! 😄가드의 능력 시험하기 🧪우리가 만든 가드가 잘 동작하는지 확인해보려고 해요. 우리가 만든 가드는 모든 요청을 허용하도록 설계되었으니, 모든 요청이 성공적으로 컨트롤러에 도달해야 해요.터미널을 열고 다음 명령어를 입력해봅시다!$ curl http://localhost:3000터미널에 ‘Hello World!’라는 응답이 오면 성공이에요! 🌟이제 가드의 능력을 더 강화해볼까요? 가드가 악당(안전하지 않은 요청)을 잘 막아낼 수 있도록 canActivate 메서드를 수정해볼 거에요.canActivate() { console.log('인증이 실패하였습니다.'); return false;}이제 안전하지 않은 요청은 모두 가드에 막힐 거에요. 다시 한 번 터미널에서 요청을 보내보면 403 Forbidden 오류가 나타나는 걸 볼 수 있어요. 무서운 악당들은 이제 우리 성에 들어올 수 없어요! 💪이렇게 가드를 통해 우리 애플리케이션을 안전하게 지킬 수 있어요. NestJS 가드는 정말 강력한 보안 경비병이죠? 🛡️이제 여러분도 NestJS 가드를 이용해서 자신만의 안전한 성을 지키는 경비병을 만들 수 있어요! 💂‍♂️💂‍♀️" }, { "title": "자바스크립트로 베개 싸움을 하다 아니 배열을 정렬하는 법!", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EB%B2%A0%EA%B0%9C-%EC%8B%B8%EC%9B%80%EC%9D%84-%ED%95%98%EB%8B%A4-%EC%95%84%EB%8B%88-%EB%B0%B0%EC%97%B4%EC%9D%84-%EC%A0%95%EB%A0%AC%ED%95%98%EB%8A%94-%EB%B2%95!/", "categories": "JavaScript", "tags": "자바스크립트배열", "date": "2023-05-18 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 자바스크립트에서 배열을 정렬하는 법을 배워볼 거예요. 여러분은 베개 싸움을 해본 적 있나요? 배열 정렬은 마치 여러 개의 베개를 깔끔하게 정리하는 것과 비슷해요! 더 이상 기다리지 않고, 자바스크립트의 sort()와 toSorted() 함수를 활용하여 친구들과 함께 배열 정렬의 세계로 빠져보도록 해요! 😊베개(배열) 정리의 기본! sort() 함수우리가 자바스크립트에서 가장 많이 사용하는 함수는 바로 sort() 함수에요! 이 친구를 사용하면 배열을 아주 쉽게 정리할 수 있어요. 😌[3, 1, 2].sort();// [1, 2, 3]위의 예시에서 볼 수 있듯이, 이 함수는 배열 안의 숫자들을 오름차순으로 정렬해 주었어요. 잘 보면 3-1-2가 아니라 1-2-3으로 깔끔하게 정리된 걸 볼 수 있죠? 😉그런데 여기에 조금의 주의점이 있어요! 이 함수는 문자열을 기준으로 정렬을 해버리기 때문에, 숫자 배열을 정렬할 때는 약간의 문제가 발생할 수 있어요. 🤔[100, 3, 1, 20].sort();// [1, 100, 20, 3]오잉, 이게 뭐죠? 우리가 원한 순서가 아니에요! 여러분들도 볼 수 있듯이, 문자열 비교에서는 첫 글자만을 기준으로 정렬을 하게 되죠. 그래서 이런 엉뚱한 결과가 나타나는 거예요! 😱숫자 배열 제대로 정렬하기자, 그럼 이 문제를 어떻게 해결할까요? 걱정 마세요, 방법은 있어요! 우리는 sort() 함수 안에 조금의 마법을 더할 수 있거든요. 이 마법은 바로 콜백 함수를 사용하는 거예요! 🧙[-3, 2, 0, 1, 3, -2, -1].sort((a, b) =&gt; a - b);// [-3, -2, -1, 0, 1, 2, 3]보세요, 이제 배열이 제대로 정렬되었어요! 여러분도 이 마법을 사용해서 숫자 배열을 원하는 순서로 정렬할 수 있을 거예요! 😎복잡한 객체 배열도 정렬할 수 있어요!그런데 현실 세계에서는 단순한 숫자보다 더 복잡한 정보를 다루는 경우가 훨씬 많죠. 우리는 객체 배열도 정렬할 수 있어요! 🥳const countries = [ { no: 1, code: \"KR\", name: \"Korea\" }, { no: 2, code: \"CA\", name: \"Canada\" }, { no: 3, code: \"US\", name: \"United States\" }, { no: 4, code: \"GB\", name: \"United Kingdom\" }, { no: 5, code: \"CN\", name: \"China\" },];위와 같은 국가 정보를 담고 있는 객체 배열을 정렬해볼까요? 여기서는 국가 코드를 기준으로 정렬해볼 거예요. 문자열 비교를 위해 localeCompare() 함수를 사용하면 아주 쉽게 정렬할 수 있어요! 🌏countries.sort((a, b) =&gt; a.code.localeCompare(b.code));// 결과 생략마치며오늘은 배열을 정렬하는 마법 같은 방법들을 배워봤어요! 이제 여러분들도 자바스크립트로 깔끔한 배열 정리 마스터가 될 수 있을 거예요. 😁그럼 모두 행복한 코딩 시간 되세요! 안녕! 👋" }, { "title": "메타 프레임워크의 본질 특징과 필요성 쉽게 알아보기", "url": "/posts/%EB%A9%94%ED%83%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EC%9D%98-%EB%B3%B8%EC%A7%88-%ED%8A%B9%EC%A7%95%EA%B3%BC-%ED%95%84%EC%9A%94%EC%84%B1-%EC%89%BD%EA%B2%8C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/", "categories": "JavaScript", "tags": "메타, 프레임워크", "date": "2023-05-17 20:00:00 +0900", "snippet": "메타 프레임워크란 무엇인가요? 🧐안녕하세요, 여러분! 😊 오늘은 약간 어려운 주제를 쉽게 풀어보려고 합니다. 뭘까요? 바로 “메타 프레임워크”라는 이름의 신비한 세계입니다. 우리는 이것을 정복해 볼 거예요!메타 프레임워크는 말 그대로 ‘프레임워크 위의 프레임워크’라는 의미입니다. “에이, 또 프레임워크야?”라고 생각할 수 있는데요, 이것은 정말 특별한 친구랍니다! 이 친구는 우리에게 다양한 UI 프레임워크들을 편리하게 사용할 수 있는 기본 틀을 제공해 준답니다.😎메타 프레임워크의 특징들 ✨자, 그럼 메타 프레임워크가 어떤 특별한 기능을 하는지 자세히 알아볼까요? 쉬운 선택: 메타 프레임워크는 프로그래머들이 쉽게 원하는 라이브러리와 프레임워크를 선택할 수 있도록 도와줍니다. 빠른 개발: 각종 툴과 라이브러리가 잘 조합되어 있어, 개발 시간을 단축해 줍니다. 주관적 선택: 메타 프레임워크는 기본적으로 ‘주관적인 선택’을 제시해줍니다. 이는 개발자가 어떤 것을 선택할지 고민하는 시간을 줄여준다는 의미입니다!왜 메타 프레임워크가 필요할까요? 🤔자, 이제 왜 이 친구가 필요한지 알아볼까요? 개발을 할 때에는 라이브러리와 프레임워크 선택이 정말 중요한데요, 이 선택을 잘못하면 나중에 더 복잡하고 어려운 문제들이 생길 수 있어요.😱메타 프레임워크는 이런 고민에서 우리를 구해주는 수퍼 히어로 같은 존재입니다! 웹 애플리케이션을 만들 때 필요한 다양한 요소들(라우팅, 데이터 패칭, 스타일링 등)에 대해 사전에 잘 선택된 조합을 제공해 준답니다. 🦸‍♂️결론: 메타 프레임워크, 우리의 새로운 친구 🥳이렇게 봤을 때 메타 프레임워크는 정말 우리의 편이 될 수 있는 멋진 도구라는 것을 알 수 있죠? 이 친구와 함께라면 더 쉽고 빠르게 웹 개발의 세계를 탐험할 수 있을 거예요!이제 메타 프레임워크라는 새로운 친구와 함께 웹 개발의 신세계로 모험을 떠나볼 준비가 되셨나요? 차근차근, 한 발짝씩 나아가면서 메타 프레임워크의 힘을 느껴보세요!" }, { "title": "자바스크립트의 미사리! substr()와 substring() 뭐가 다를까", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EB%AF%B8%EC%82%AC%EB%A6%AC!-substr()%EC%99%80-substring()-%EB%AD%90%EA%B0%80-%EB%8B%A4%EB%A5%BC%EA%B9%8C/", "categories": "JavaScript", "tags": "자바스크립트, substr, substring", "date": "2023-05-16 20:00:00 +0900", "snippet": "안녕하세요! 여러분 모두가 자바스크립트의 세계에 발을 들이면 반드시 마주치게 되는 두 대장장이 substr()와 substring()! 이 두 친구, 겉보기에는 쌍둥이 같지만 사실은 성격이 천차만별인 녀석들입니다. 🤯 오늘은 이 두 함수의 다양한 모습을 함께 살펴보며, 그 차이점을 한번 파헤쳐보도록 하겠습니다!substr() 함수 깊게 알아보기 🧐자, 첫 번째로 만나볼 친구는 substr()이에요. 이 친구는 문자열의 일부를 마치 손으로 잘라내듯이 가져와 줍니다. 🎉\"문자열\".substr(시작 인덱스, 길이);놀라운 건, 이 친구, 시작 인덱스에서부터 원하는 길이만큼 잘라준답니다. 그렇다면 “ABCDEFG”에서 2번째부터 3글자를 잘라볼까요?\"ABCDEFG\".substr(2, 3); // \"CDE\"어떤가요, 멋지죠? 😎이제 한 가지 더! 길이를 지정하지 않으면 어떻게 될까요?\"ABCDEFG\".substr(2); // \"CDEFG\"와우, 시작 인덱스부터 끝까지 가져오는군요! 🚀substring() 함수, 그 녀석은 어떤가? 🤔이제 두 번째 주인공 substring()의 차례입니다. 이 친구는 시작 인덱스와 종료 인덱스를 기준으로 문자열을 잘라줍니다. 😮\"문자열\".substring(시작 인덱스, 종료 인덱스);자, “ABCDEFG”에서 2번째부터 5번째 이전까지 가져와볼까요?\"ABCDEFG\".substring(2, 5); // \"CDE\"이 친구는 종료 인덱스 바로 전까지만 가져온답니다! 🎁이제, 시작 인덱스만 넘기면 어떻게 될까요?\"ABCDEFG\".substring(2); // \"CDEFG\"우와, substr()처럼 작동하는군요! 🎈substr()와 substring() 대결! ⚔️이제 이 두 녀석을 머리 대 머리로 대결시켜 볼 시간입니다! substr(): 시작 인덱스와 길이를 기준으로 문자열을 잘라줍니다. 🥊 substring(): 시작 인덱스와 종료 인덱스를 기준으로 문자열을 잘라줍니다. 🥋모두 같은 자바스크립트 가족이지만, 각각 성격이 다르니까 주의해서 사용해야 해요! ☝️이제 여러분도 substr()과 substring() 함수의 차이를 마스터했습니다!" }, { "title": "자바스크립트로 웹 주소 마스터 되기!", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EC%9B%B9-%EC%A3%BC%EC%86%8C-%EB%A7%88%EC%8A%A4%ED%84%B0-%EB%90%98%EA%B8%B0!/", "categories": "JavaScript", "tags": "자바스크립트, 웹주소", "date": "2023-05-15 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 잠깐 멈추고 주변을 둘러볼 시간입니다. 왜냐하면 여러분이 매일 사용하는 그 것, 바로 URL에 대해서 알아볼 시간이거든요! 💫URL이 뭐에요? 🤔어, 일단 정지! “URL이 뭐야?”라고 묻지 마세요. 괜히 부끄러워질 거에요. 😅 URL은 우리가 인터넷 세상에서 집 찾아가기 위해 꼭 필요한 주소라고 생각하면 돼요. 주소 없으면 어디로 가야 할지 모르잖아요? 마찬가지로, 웹 사이트도 주소가 필요해요. 그 주소가 바로 URL이에요!URL을 구성하는 친구들 소개합니다! 🎉이제부터는 URL을 이루는 여러 부분들을 하나씩 소개할게요. 미리 알아둔다면, 나중에 URL을 다룰 때 정말 큰 도움이 됩니다!스키마(Scheme) or 프로토콜(Protocol)먼저 오는 부분은 스키마라고 하는데, 이 부분이 URL의 규칙을 정하는 부분이에요. ‘http:’ 또는 ‘https:’와 같은 형태로 표현된답니다.호스트 네임(Hostname)그 다음은 호스트 네임이라고 해요. 이 부분이 URL의 집 주소라고 생각하면 돼요. 예를 들면, ‘example.org’ 같은 것이죠.포트(Port)호스트 네임 뒤에 나오는 숫자 부분은 ‘포트’라고 하는데, 집에 있는 방 번호라고 생각하면 편해요. 각각의 방에는 다른 내용이 담겨 있겠죠?경로명(Pathname)그 다음은 경로명이라고 해요. 이 부분은 우리가 찾고자 하는 정보가 어디에 있는지를 알려준답니다.쿼리 스트링(Query String)쿼리 스트링은 URL에서 ‘?’ 뒤에 나오는 부분으로, 어떤 정보를 찾고 싶은지 더 구체적으로 알려주는 역할을 해요.앵커(Anchor) 또는 조각(Fragment)마지막으로, ‘#’ 뒤에 나오는 부분은 앵커 또는 조각이라고 해요. 이 부분은 페이지의 특정 부분으로 바로 가게 해주는 역할을 합니다.마무리자, 이제 URL에 대해서 알게 되었어요. 다음 번에는 더 심도 있게 알아볼게요. 그럼, 다음에 또 만나요! 👋" }, { "title": "Prettier를 편리하게 사용해보자!", "url": "/posts/Prettier%EB%A5%BC-%ED%8E%B8%EB%A6%AC%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90!/", "categories": "JavaScript", "tags": "Prettier", "date": "2023-05-14 20:00:00 +0900", "snippet": "안녕하세요, 모든 개발자 여러분! 여러분들은 자바스크립트 코드를 깔끔하고 예쁘게 작성하는 것에 어려움을 느끼지 않으신가요? 그렇다면 바로 Prettier를 사용해보는 것은 어떨까요? 오늘은 Prettier를 편리하게 사용할 수 있는 방법에 대해 알아보도록 해요! 🌈Prettier 설정의 ABC 🛠Prettier는 자바스크립트에서 가장 인기 있는 코드 포맷터로, 코드를 일관성 있게 꾸며주는 역할을 합니다. 설정은 크게 세 가지 방법이 있는데, 하나하나 함께 알아볼게요! 😊1️⃣ 커맨드 라인에서 설정하기첫 번째 방법은 간편하게 한 번 사용할 때 좋은 방법입니다. 커맨드 라인에 다음과 같이 작성하면 되요:$ prettier . --single-quote --print-width 100 --arrow-parens avoid하지만 많은 설정을 해야할 때는 이 방법이 오히려 불편할 수도 있어요. 그럴 땐 다른 방법을 사용해볼까요?2️⃣ package.json에서 설정하기두 번째 방법은 package.json 파일에서 Prettier 설정을 하는 것이에요! 아래와 같이 작성하면 됩니다:{ // ... \"prettier\": { \"singleQuote\": true, \"printWidth\": 100, \"arrowParens\": \"avoid\" }}package.json 파일에 설정을 해두면, 프로젝트 설정을 한눈에 볼 수 있어 편리하답니다! 😄3️⃣ 별도의 설정 파일을 만들어 사용하기마지막으로, 별도의 설정 파일을 만드는 방법이 있어요. 여러분이 원하는 확장자로 파일을 만들어 설정을 저장할 수 있어요. 예를 들어, .prettierrc 파일을 사용해봅시다:{ \"singleQuote\": true, \"printWidth\": 100, \"arrowParens\": \"avoid\"}이 방법은 프로젝트에 새로 합류하는 개발자들이 쉽게 설정을 확인할 수 있어 매우 유용해요!Prettier 설정 옵션 알아보기 🕵️이제 Prettier 설정에서 사용할 수 있는 몇 가지 옵션들을 함께 알아볼까요?따옴표 설정 🐦따옴표를 '(홑따옴표)로 사용하고 싶다면 singleQuote 옵션을 true로 설정하면 되요. 이렇게 설정하면 코드가 더 깔끔해 보일 수도 있답니다!한 줄의 글자 수 📏한 줄에 글자 수를 제한하려면 printWidth 옵션을 사용하면 되요. 대부분은 80자를 사용하지만, 와이드 모니터를 사용하는 분들은 100자도 괜찮다고 해요!세미콜론 사용 🔚세미콜론은 각 문장의 끝에 붙이는 오래된 관행이에요. 하지만, 이제는 semi 옵션을 false로 설정하여 세미콜론을 생략할 수도 있답니다!후행 쉼표 설정 🚀마지막으로, 후행 쉼표 설정인데요, 여러 줄에 걸친 배열이나 객체, 매개변수 뒤에 쉼표를 추가하려면 trailingComma 옵션을 사용하면 되요. 쉼표를 없애려면 \"none\"으로 설정하면 됩니다!마무리 🌟오늘은 Prettier 설정 방법과 옵션들을 알아봤어요! 여러분들도 이 설정들을 사용해서 코드를 더 깔끔하고 예쁘게 작성해보세요! 다음에 또 뵐게요~ 😄" }, { "title": "JavaScript에서 쿼리 스트링 다루기 URLSearchParams로 편안하게!", "url": "/posts/JavaScript%EC%97%90%EC%84%9C-%EC%BF%BC%EB%A6%AC-%EC%8A%A4%ED%8A%B8%EB%A7%81-%EB%8B%A4%EB%A3%A8%EA%B8%B0-URLSearchParams%EB%A1%9C-%ED%8E%B8%EC%95%88%ED%95%98%EA%B2%8C!/", "categories": "JavaScript", "tags": "자바스크립트, 쿼리스트링, URLSearchParams", "date": "2023-05-13 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 여러분은 웹 개발을 할 때 URL에 있는 쿼리 스트링(🤔 뭐지? 물음표(?) 뒤에 따라오는 그 긴 문자열이다!)을 다루는 법을 어떻게 알고 계신가요? 네, 네, 전 정확히 알고 있습니다. 그런 복잡하고 어려운 일들은 이제 그만! 자바스크립트의 URLSearchParams를 사용하면 그런 걱정은 없어져요! 자, 그럼 함께 본격적으로 시작해볼까요?URLSearchParams의 탄생 이야기자바스크립트의 세계에서 새롭게 등장한 슈퍼 히어로 URLSearchParams는 URL에 있는 쿼리 스트링을 다루기 위해 나타났어요. 😎 이 친구를 사용하면 쿼리 스트링을 더 안전하게, 그리고 더 쉽게 다룰 수 있어요. 어떻게 사용하는지 함께 알아볼까요?객체 생성 마법🧙‍♂️마법의 시작은 객체 생성부터 시작된답니다. 우리는 URLSearchParams 객체를 다양한 방법으로 만들 수 있어요.// 방법 1: 2차원 배열을 사용하는 방법new URLSearchParams([ [\"mode\", \"dark\"], [\"page\", 1], [\"draft\", false], [\"sort\", \"email\"], [\"sort\", \"date\"],]);// 방법 2: 쿼리 스트링 문자열을 사용하는 방법new URLSearchParams(\"?mode=dark&amp;page=1&amp;draft=false&amp;sort=email&amp;sort=date\");// 혹은 ? 기호를 생략해도 됩니다!new URLSearchParams(\"mode=dark&amp;page=1&amp;draft=false&amp;sort=email&amp;sort=date\");기억하세요! 우리는 이 마법을 사용하여 빈 객체를 만든 후에 나중에 파라미터를 추가할 수도 있다는 것을!쿼리 스트링을 속속들이 알아보기이제 쿼리 스트링 안을 들여다 볼 차례입니다! 😄 URLSearchParams 객체에는 size 속성이 있어요. 이 속성으로 쿼리 스트링에 얼마나 많은 매개변수가 있는지 셀 수 있답니다!const searchParams = new URLSearchParams(\"mode=dark&amp;page=1&amp;draft=false\");console.log(searchParams.size); // 출력: 3하지만 여기서 주의! 동일한 키에 여러 값이 있는 경우, 값의 개수를 기준으로 size 속성이 계산된답니다!const searchParams = new URLSearchParams(\"sort=date&amp;sort=email\");console.log(searchParams.size); // 출력: 2아, 그리고 Set을 사용하면 유일한 키의 개수도 찾을 수 있어요!console.log([...new Set(searchParams.keys())].length); // 출력: 1URLSearchParams의 마법 스킬들URLSearchParams 객체는 여러 가지 마법 스킬을 가지고 있답니다! 👍toString() 메서드: 문자열 변환기toString() 메서드는 우리가 만든 쿼리 스트링을 다시 문자열로 바꾸는 데 사용된답니다. 아래 코드를 보세요!const searchParams = new URLSearchParams();console.log(searchParams.toString()); // 출력: ''const searchParams = new URLSearchParams([ [\"mode\", \"dark\"], [\"page\", 1], [\"draft\", false],]);console.log(searchParams.toString()); // 출력: 'mode=dark&amp;page=1&amp;draft=false'append()와 set() 메서드: 파라미터 조종사append() 메서드로 새로운 파라미터를 추가할 수 있어요. 그리고 set() 메서드를 사용하면 기존 파라미터의 값을 바꿀 수 있어요.const searchParams = new URLSearchParams();searchParams.append(\"mode\", \"dark\");searchParams.append(\"page\", 1);// 더 많은 파라미터 추가아마 여러분도 이제 URLSearchParams의 마법을 사용할 준비가 된 것 같네요! ✨ 그럼, 행복한 코딩 되세요!" }, { "title": "자바스크립트로 여행을 떠나요!", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EC%97%AC%ED%96%89%EC%9D%84-%EB%96%A0%EB%82%98%EC%9A%94!/", "categories": "JavaScript", "tags": "자바스크립트", "date": "2023-05-12 20:00:00 +0900", "snippet": "안녕하세요, 자바스크립트 여행자 여러분! 오늘은 자바스크립트의 마법 같은 세계로 여러분을 안내해 드리려고 해요. 특별히 오늘은 페이지 이동이라는 멋진 주제로 함께 여행을 떠나보겠습니다. 🧳페이지 이동의 신비로운 세계 🌏웹 세계에서 페이지 이동은 마치 여행을 떠나는 것과 같아요. 브라우저 창을 열 때마다, 다양한 경험을 쌓을 수 있는 여행지로 떠나게 되죠! 우리가 함께 이야기할 첫 번째 멈춤은 window.location 프로퍼티입니다!✨window.location 프로퍼티 탐험window.location 프로퍼티는 여러분의 브라우저가 지금 있는 ‘위치’를 알려줘요. 즉, 현재 페이지의 URL 정보를 알 수 있는 곳이에요! 이곳에서 URL의 다양한 부분, 예를 들어 ‘프로토콜’이라는 길이나 ‘호스트네임’이라는 호텔을 찾아볼 수 있어요.🌈 다채로운 URL 정보 소개URL 정보 속에는 여러가지 놀라운 것들이 담겨 있어요! 프로토콜: 웹 페이지의 규칙을 결정하는 부분이에요! 호스트네임: 웹 사이트의 이름이 위치한 곳이죠! 포트: 정보가 들어오는 문이라고 생각하시면 돼요! 경로명: 여러분이 찾고 있는 페이지의 정확한 경로를 알려줘요!🚪 location.href 변경으로 떠나는 여행이제, 우리는 location.href로 새로운 여행지로 떠나볼 거에요. 링크를 바꾸면, 새로운 경험이 담긴 페이지로 이동할 수 있어요! 그리고 걱정 마세요, “뒤로 가기” 버튼을 누르면 언제든지 이전의 멋진 여행지로 돌아갈 수 있어요.하지만! 이 방법은 조금 복잡한 단계를 거쳐야 해요. 😅 우리는 이러한 복잡함을 극복하기 위해 특별한 꼼수를 사용해 볼 거에요!🤫 꼼수를 사용한 여행 준비때로는 여행을 준비하면서 어려움이 발생할 수 있어요. 타입 에러라는 짐을 가지고 여행을 떠나기 싫다면, 작은 꼼수를 사용해야 해요! 그러니 이 꼼수를 기억해두세요:(window as Window).location = \"https://www.daleseo.com\";이제, 준비가 된 것 같네요! 그럼, 다음 여행지로 떠나볼까요?🚀 location.assign()으로 더 빠른 여행마지막으로 소개할 방법은 location.assign() 메서드를 사용하는 것이에요! 이 메서드를 사용하면, 더 빠르게 다음 여행지로 떠날 수 있어요.location.assign(\"https://www.daleseo.com\");여정의 마무리 🏁자, 여러분! 우리의 자바스크립트로 된 여행이 이제 마무리되어 가네요. 오늘 배운 여러 방법을 사용해서, 여러분만의 웹 페이지 여행을 계획해보세요!기억하세요, 여행은 언제나 여러분을 기다리고 있어요! 자바스크립트와 함께라면, 어디든 떠날 수 있습니다.그럼, 다음 여행에서 만나요! 안녕! 👋" }, { "title": "자바스크립트로 배열을 합치는 마법 같은 방법들!", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EB%B0%B0%EC%97%B4%EC%9D%84-%ED%95%A9%EC%B9%98%EB%8A%94-%EB%A7%88%EB%B2%95-%EA%B0%99%EC%9D%80-%EB%B0%A9%EB%B2%95%EB%93%A4!/", "categories": "JavaScript", "tags": "자바스크립트배열", "date": "2023-05-11 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 🧙‍♂️ 오늘은 우리가 자주 사용하는 자바스크립트에서 배열을 합치는 마법 같은 방법들을 배워볼 거에요. 함께 하나하나 살펴보며 우리의 마법 지식을 키워볼까요? 🌟concat 메서드로 시작하는 마법 기초 학습 📖자, 첫 번째로 배울 마법은 concat 메서드에요. 이 메서드는 마치 두 개의 물건을 하나로 합쳐버리는 마법과 같아요! 예쁘게 정리된 숫자 배열과 글자 배열이 있다고 상상해볼게요. 이제 이 두 배열을 concat 메서드로 합쳐 볼까요?const numbers = [1, 2, 3];const letters = [\"A\", \"B\"];const concatenated = numbers.concat(letters);console.log(concatenated); // [1, 2, 3, 'A', 'B']와, 보세요! 숫자 배열과 글자 배열이 하나로 합쳐져서 새로운 배열이 탄생했어요! 🐣새로운 배열을 창조하면서 원본은 그대로 🌟concat 메서드는 아주 친절하게도 원본 배열은 손대지 않아요. 그래서 원본 배열을 보존하면서 새로운 배열을 만들 수 있답니다.console.log(numbers); // [1, 2, 3]console.log(letters); // ['A', 'B']다른 메서드와 함께 사용해서 더 복잡한 마법도 쓸 수 있어요. 궁금하신가요? 한번 해볼까요? 🧙‍♀️[1, 2, 3] .concat([\"A\", \"B\"]) .map((item) =&gt; item + item) .reduce((acc, val) =&gt; acc + val, \"\"); // '246AABB'위와 같이 써서, 배열에 담긴 요소들을 두 배로 불려서 하나의 문자열로 합쳐봤어요!…으로 전개하는 마법 🎩두 번째 마법은 전개 연산자라고 불리는 ... 기호를 사용한 방법이에요. 이 기호를 사용하면 배열을 펼칠 수 있어요.const numbers = [1, 2, 3];const letters = [\"A\", \"B\"];const spread = [...numbers, ...letters];console.log(spread); // [1, 2, 3, 'A', 'B']이 기호를 사용하면 배열뿐만 아니라 일반 값도 배열에 추가할 수 있어요.배열 복제의 마법도 가능해요! 🔄전개 연산자를 사용하면 원본 배열을 복제하는 마법도 할 수 있어요!const original = [1, 2, 3];const clone = [...original];console.log(original); // [1, 2, 3]console.log(clone); // [1, 2, 3]물론 concat 메서드를 사용해서도 같은 마법을 할 수 있답니다!const original = [1, 2, 3];const clone = [].concat(original);console.log(original); // [1, 2, 3]console.log(clone); // [1, 2, 3]이렇게 두 가지 방법으로 배열을 복제할 수 있어요. 어떤 방법이 더 좋다고 단정지을 수 없어요. 마법사님의 취향에 따라 선택하면 되겠죠? 😊마무리 ✨우리가 오늘 배운 마법은 자바스크립트에서 배열을 합치는 concat 메서드와 전개 연산자에요. 이제 여러분도 이 마법들을 사용해서 아름다운 코드를 만들 수 있겠죠? 항상 연습하고, 새로운 마법도 찾아보세요! 💫감사합니다, 모든 마법사 여러분! 다음에 또 만나요~ 🌈" }, { "title": "자바스크립트 History API 마법의 카펫 타기", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-History-API-%EB%A7%88%EB%B2%95%EC%9D%98-%EC%B9%B4%ED%8E%AB-%ED%83%80%EA%B8%B0/", "categories": "JavaScript", "tags": "HistoryAPI", "date": "2023-05-10 20:00:00 +0900", "snippet": "재미있게 알아보는 SPA와 라우팅!안녕하세요, 😎 SPA(Single Page Application) 세계에서는 클라이언트 단에서 라우팅을 하는데, 이것은 마치 우리가 마법의 카펫에 탄 것 같은 기분이 들게 해줘요. React나 Vue.js 같은 라이브러리와 함께 라우팅 라이브러리를 사용하면, 마법의 카펫은 더욱 빠르게 날아가게 돼요! 🚀히스토리 API: 시간여행을 떠나보자!History API는 브라우저가 관리하는 세션 히스토리, 즉 페이지 방문 이력을 제어하는 역할을 해요. 세션은 사용자가 브라우저의 새 창이나 탭을 열 때 생성되고 닫을 때 사라져요. 마치 시간 여행을 할 때 쓰이는 타임머신 같은 거죠! 🕰이제 라우팅을 시작해 볼까요?라우팅을 시작하기 전에 먼저 현재 세션에서 방문한 페이지가 몇 개인지 확인해볼 수 있는 방법을 알아볼까요? History API에서 제공하는 length 프로퍼티를 통해 확인해보세요. 얼마나 많은 장소를 여행했는지 알아보는 것, 꽤 재미있지 않나요? 😊history.length; // 1window.history.length; // 1document.history.length; // 1뒤로 가기, 앞으로 가기: 여행의 자유를 누리자History API를 사용하면 브라우저에서 뒤로 가기나 앞으로 가기를 할 수 있어요. 그러니까, 우리는 마법의 카펫을 타고 시간을 오가며 여행할 수 있어요! 🌈history.back(); // 뒤로 가기history.forward(); // 앞으로 가기go() 메서드: 더 놀라운 마법의 카펫go() 메서드는 더욱 특별한 여행을 제공해요. 인자로 받는 숫자에 따라 여러 페이지를 건너뛰거나 현재 페이지를 새로고침 할 수 있어요. 즉, 이 메서드 하나로 여러 가지 마법을 쓸 수 있어요! 🪄history.go(-2); // 뒤로 2번 가기history.go(1); // 앞으로 1번 가기SPA에서의 사용 방법하지만 SPA에서는 history.back(), history.forward(), history.go() 메서드를 잘 사용하지 않아요. 왜냐하면 이 메서드들을 사용하면 페이지가 리로드되버리니까요. SPA는 일부만 업데이트하면서 전체 페이지를 다시 로딩하지 않는 마법을 사용하거든요. 🎩✨History API로 URL 마법을 부리자!History API로 현재 URL을 바꾸는 마법도 가능해요! pushState()와 replaceState() 메서드로 URL을 조작할 수 있어요. 이렇게 해서 우리는 마법의 카펫 위에서 더욱 다양한 모험을 떠날 수 있답니다! 🌍이렇게 자바스크립트 History API의 마법 세계 여행이 끝났어요. History API로 더욱 다채로운 웹 어플리케이션 여행을 준비해보세요! 여러분의 상상력이 더해진 마법의 카펫은 어디든 갈 수 있어요! 😊" }, { "title": "리액트에서 안전하게 위치정보 다루기", "url": "/posts/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EC%9C%84%EC%B9%98%EC%A0%95%EB%B3%B4-%EB%8B%A4%EB%A3%A8%EA%B8%B0/", "categories": "JavaScript", "tags": "리액트위치정보", "date": "2023-05-09 20:00:00 +0900", "snippet": "안녕하세요! 함께하는 코딩 시간입니다. 오늘은 리액트(React) 앱에서 브라우저의 위치 객체에 안전하게 접근하는 방법에 대해 알아볼 거예요. 먼저, 몇 가지 기초 개념부터 시작해볼까요?🌏 위치 객체란 무엇일까요?위치 객체라는 것은 브라우저에서 현재 페이지의 정보를 담고 있는 객체에요. 이 객체는 여러 프로퍼티로 이루어져 있어요. 예를 들면, ‘프로토콜(protocol)’, ‘호스트네임(hostname)’, ‘포트(port)’, ‘경로명(pathname)’ 등이 있죠. 간단히 말하면, 이 위치 객체는 현재 페이지의 URL 정보를 담고 있는 상자 같은 것이라고 생각하시면 돼요.❓ window.location에 접근하면 발생하는 문제는?이제 리액트 컴포넌트에서 window.location을 통해 위치 정보를 읽을 때 발생하는 문제에 대해 알아볼 차례에요. 여러분이 만약 버튼을 클릭해서 URL을 바꾸고 나서 새로고침을 한다면, 화면에 맞는 현재 경로가 표시되는 것을 볼 수 있을 거에요. 그런데 이렇게 해도 현재 경로는 자동으로 갱신되지 않아요. 왜 그럴까요? 🤔🖌 해결책: location 상태 추가하기잠깐, 문제 해결의 신이 여러분에게 왔어요! 리액트에서는 상태(state)라는 기능을 통해 이 문제를 해결할 수 있어요. 현재 URL을 컴포넌트의 상태로 저장하면, URL이 바뀔 때마다 UI도 자동으로 갱신된다는 것이죠! 🎉import React from \"react\";function App() { const [location, setLocation] = React.useState({ ...window.location }); const navigate = (path) =&gt; { window.history.pushState({}, \"\", path); setLocation({ ...window.location }); }; return ( &lt;&gt; &lt;header&gt; &lt;button onClick={() =&gt; navigate(\"/home\")}&gt;Home&lt;/button&gt; &lt;button onClick={() =&gt; navigate(\"/about\")}&gt;About&lt;/button&gt; &lt;button onClick={() =&gt; navigate(\"/users/1\")}&gt;User 1&lt;/button&gt; &lt;button onClick={() =&gt; navigate(\"/users/2\")}&gt;User 2&lt;/button&gt; &lt;/header&gt; &lt;main&gt; &lt;h1&gt;현재 경로는 {location.pathname} 입니다.&lt;/h1&gt; &lt;/main&gt; &lt;/&gt; );}🔄 PopState 이벤트 처리하지만 여기서 끝이 아니에요! ‘뒤로 가기’와 ‘앞으로 가기’ 버튼을 눌렀을 때도 현재 경로를 올바르게 보여주려면 어떻게 해야 할까요? 여러분, 손가락을 튕겨주며 한 번 생각해보세요!이제 우리는 ‘PopState’ 이벤트 처리를 해야 한다는 것을 알게 되었어요. 이 이벤트는 브라우저의 이전 또는 다음 버튼을 클릭할 때 발생하게 되는데요, 이를 처리해주면 더 이상 문제 없이 현재 경로를 보여줄 수 있게 됩니다!즉, PopState 이벤트를 사용하면 뒤로 가기와 앞으로 가기 버튼을 눌렀을 때 현재 경로가 올바르게 갱신될 것이에요. 👍✨ 마치며오늘은 리액트에서 위치 객체를 안전하게 다루는 방법에 대해 알아봤어요. 여러분도 이제 리액트 앱을 만들 때 이 지식을 활용해서 멋진 앱을 만들 수 있을 거에요!저희와 함께 코딩의 세계를 탐험하면서 즐거운 시간 보내셨기를 바라요. 더 궁금한 것이 있다면 언제든지 물어봐주세요.다음 시간에도 더 신나는 코딩 이야기로 찾아올게요. 그때 뵙겠습니다, 코드 마스터님들! 😄" }, { "title": "Faker 라이브러리를 활용한 재미있는 가짜 데이터 생성", "url": "/posts/Faker-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%9E%AC%EB%AF%B8%EC%9E%88%EB%8A%94-%EA%B0%80%EC%A7%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%83%9D%EC%84%B1/", "categories": "JavaScript", "tags": "Faker라이브러리", "date": "2023-05-08 20:00:00 +0900", "snippet": "안녕하세요, 코딩 놀이터에 오신 것을 환영합니다! 오늘은 우리가 개발할 때 매우 유용하게 사용할 수 있는 가짜 데이터 생성 라이브러리인 Faker 라이브러리에 대해 알아볼 거예요. 자, 준비되셨나요? 🚀 함께 떠나보아요!🌈 가짜 데이터라는 특별한 친구먼저, 가짜 데이터는 왜 필요한지, 그 특별함이 무엇인지 함께 알아보죠!이 친구는 테스트를 할 때, 아니면 새로운 서비스를 만들어 볼 때 정말 큰 도움이 되는 친구랍니다. 🤖 개발자들은 이 가짜 데이터를 사용해서 현실에서 발생할 수 있는 다양한 상황을 미리 예측하고 대비할 수 있어요. 아무래도 진짜 데이터보다는 노동력이 적게 드니까 많은 사랑을 받고 있죠! 💖💫 Faker 라이브러리와의 첫 만남그러면 이제 Faker 라이브러리를 설치해 볼까요? 콘솔에 아래 명령어를 입력해주세요!npm i -D @faker-js/faker잘 설치되셨나요? 👍 이제 우리는 이 라이브러리를 사용할 준비가 끝났습니다!🌟 Faker의 다양한 기능 탐구👦🏻 가짜 사용자 정보 생성하기Faker 라이브러리는 가짜 사용자 데이터를 생성해주는 특별한 기능을 가지고 있어요. 이제 개발을 하다가 필요할 때마다 새로운 가상의 친구를 만들어 볼 수 있겠네요! 🎉import { faker } from \"@faker-js/faker\";console.log(faker.person.firstName()); // 'Claude'console.log(faker.person.lastName()); // 'Mueller'💻 가짜 인터넷 데이터 만들기이 기능은 인터넷과 관련된 가짜 데이터, 예를 들어 이메일이나 비밀번호를 만들어줘요. 신기하지 않나요? 🌐console.log(faker.internet.email()); // 'Claude_Mueller@hotmail.com'console.log(faker.internet.password()); // '3PnJkjkr3mn0tBP'📞 믿을 수 없는 가짜 전화번호 생성하기전화번호도 만들 수 있다고요? 네, 맞아요! 이제 테스트할 때 진짜 전화번호를 사용할 필요가 없어졌어요! 🎈console.log(faker.phone.number()); // '568.567.778'🎁 마치며오늘 우리는 함께 Faker 라이브러리를 통해 가짜 데이터를 만드는 방법을 배웠어요. 이제 개발을 하다가 테스트 데이터가 필요하면 이 친구를 떠올리면 되겠네요! 😊그럼 즐거운 코딩 되세요! 다음에 또 만나요! 👋" }, { "title": "자바스크립트 쿼리 스트링 라이브러리 탐방!", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%BF%BC%EB%A6%AC-%EC%8A%A4%ED%8A%B8%EB%A7%81-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%ED%83%90%EB%B0%A9!/", "categories": "JavaScript", "tags": "쿼리스트링", "date": "2023-05-07 20:00:00 +0900", "snippet": "안녕하세요, 오늘은 누구나 한 번쯤은 만나게 되는 웹 개발의 복잡한 영역, ‘쿼리 스트링(Query String)’을 살짝 더 쉽게 다루기 위한 라이브러리에 대해 얘기해볼거예요. 깜찍하게 ‘qs’와 ‘query-string’ 라이브러리로 무장하고, 쿼리 스트링 세계를 탐험해 볼까요? 🕵️쿼리 스트링, 왜 이렇게 복잡해요? 😖웹 개발을 하다 보면 쿼리 스트링을 만나게 돼요. ?key1=value1&amp;key2=value2&amp;… 형태로 나타나는 이 친구는 정말로 복잡하죠? 😵 여러 키와 값들이 쭉 이어져 있고, 이 안에 다국어나 특수 문자까지 섞이면 아주 ‘머리 아픈’ 일이 생겨요. 이렇게 복잡한 쿼리 스트링을 다룰 때 라이브러리가 빛을 발하죠!qs 라이브러리, 개발자들의 오랜 친구 🧙먼저, ‘qs’ 라이브러리부터 만나볼게요. 13년의 역사를 자랑하는 이 라이브러리는 진정한 웹 개발의 ‘베테랑’이에요! 설치 방법은 간단해요, npm을 통해 설치하면 됩니다.import * as qs from \"qs\";이렇게 가져오면 ‘qs’라는 친구의 모든 기능을 사용할 수 있어요. 자, 이제 가장 기본적인 기능부터 알아볼까요?능력 1: 문자열 → 객체 변환 🎩const obj = qs.parse(\"mode=dark&amp;active=true&amp;nums=1&amp;nums=2&amp;nums=3\");console.log(obj);이렇게 하면 쿼리 스트링이 객체로 변환돼서 출력돼요. 와~ 신기하지 않나요? 🌈능력 2: 객체 → 문자열 변환 🔄const str = qs.stringify({ mode: \"dark\", active: \"true\", nums: [\"1\", \"2\", \"3\"],});console.log(str);객체를 다시 문자열로 변환하는 것도 ‘qs’라이브러리가 쉽게 해결해줘요!query-string 라이브러리, 또 다른 신뢰할 수 있는 친구 🧑‍🔬이제 ‘query-string’ 라이브러리를 만나볼 차례에요. 이 친구도 ‘qs’만큼 유명해요!설치와 기본 사용법 💻import queryString from \"query-string\";이렇게 하면 ‘query-string’ 라이브러리를 사용할 준비가 완료된답니다!능력: 문자열 → 객체 변환 🔎const obj = queryString.parse(\"mode=dark&amp;active=true&amp;nums=1&amp;nums=2&amp;nums=3\");console.log(obj);이 친구도 ‘qs’와 마찬가지로 쿼리 스트링을 객체로 변환해줘요! 하지만 여기에는 작은 비밀이 하나 있는데요, 결과 객체가 파라미터 이름 기준으로 ‘오름차순 정렬’이 되어 나타난답니다! 🌟여러분, ‘qs’와 ‘query-string’ 라이브러리의 멋진 세계에 대해 알게 되셨나요? 😊 이 두 라이브러리를 활용하면 복잡한 쿼리 스트링도 식은 죽 먹기가 돼요!다음에도 유용한 개발 팁으로 찾아뵐게요! 행복한 코딩 되세요~ 🌈" }, { "title": "package.json 파일, 뭔지 알아볼까요", "url": "/posts/package.json-%ED%8C%8C%EC%9D%BC,-%EB%AD%94%EC%A7%80-%EC%95%8C%EC%95%84%EB%B3%BC%EA%B9%8C%EC%9A%94/", "categories": "JavaScript", "tags": "자바스크립트패키지", "date": "2023-05-06 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 오늘은 우리가 자주 마주치지만 잘 모르는 package.json 파일에 대해 알아보려고 합니다. 🎉 자, 코딩의 세계로 함께 떠나볼까요? 🚀package.json이란 무엇인가요? 🤔먼저 이 녀석이 뭐냐면, 자바스크립트 프로젝트를 도와주는 헬퍼 같은 친구랍니다! 프로젝트를 진행할 때 필요한 다양한 정보를 담고 있는 중요한 파일이에요. “내 프로젝트에 어떤 부품이 필요해?”라는 질문에 답해주는 친절한 친구라고 할 수 있겠네요! 😊파일 구조는 어떻게 되나요? 🧐scripts: 명령어 모음집 📚우리가 자주 사용하는 명령어들을 미리 정해놓고, 필요할 때마다 쉽게 사용할 수 있게 해주는 곳이 바로 scripts 필드에요!\"scripts\": { \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test\"}dependencies: 프로젝트의 필수품들 🧳dependencies는 프로젝트가 꼭 필요로 하는 친구들을 모아둔 곳이에요. 여기에 있는 패키지들은 프로젝트가 움직이려면 반드시 필요해요!\"dependencies\": { \"react\": \"^17.0.2\", \"react-dom\": \"^17.0.2\"}devDependencies: 개발할 때만 필요한 친구들 🛠️devDependencies는 개발할 때만 필요한 친구들을 모아 놓는 곳이에요. 프로젝트를 만들 때는 필요하지만, 완성된 프로젝트에서는 필요 없어요!\"devDependencies\": { \"eslint\": \"^7.32.0\"}이제 알겠어요! 😄이제 package.json 파일이 무슨 역할을 하는지 알게 되었네요! 마치 프로젝트를 만들기 위한 부품상자 같은 곳이죠. 여러분도 이 친구를 잘 활용해서 멋진 프로젝트를 만들어보세요! 🌟" }, { "title": "React로 멋진 필터 UI 만들기", "url": "/posts/React%EB%A1%9C-%EB%A9%8B%EC%A7%84-%ED%95%84%ED%84%B0-UI-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "JavaScript", "tags": "리액트필터", "date": "2023-05-05 20:00:00 +0900", "snippet": "안녕하세요, 여러분! 🚀 오늘은 React로 어떻게 상품 목록 페이지를 꾸밀 수 있는지 알아보는 시간을 가질 겁니다. 먼저 아기자기하게 필터 UI를 만들어 볼텐데요, 이 UI를 통해 사용자들은 자신이 원하는 상품만 쏙쏙 골라볼 수 있어요. 그럼 함께 만들어봅시다!상품 목록 컴포넌트 만들기 📦우리의 첫 번째 단계는 상품 목록을 보여주는 컴포넌트를 만드는 것이에요. 먼저 &lt;Products/&gt; 컴포넌트를 만들고, 여기에 상품 정보와 로딩 여부를 알려줄 prop을 넣어줍니다. 로딩이 끝나면 상품들의 이름과 사진을 화면에 보여줄 거에요! 아래 코드를 보시죠!function Products({ products, loading }) { if (loading) return ( &lt;article aria-busy=\"true\"&gt; 잠시만 기다려주세요. 상품 데이터를 불러오고 있습니다. &lt;/article&gt; ); return ( &lt;&gt; {products.map((product) =&gt; ( &lt;article key={product.id}&gt; &lt;header&gt;{product.title}&lt;/header&gt; &lt;img src={product.thumbnail} alt={product.title} /&gt; &lt;/article&gt; ))} &lt;/&gt; );}상품 데이터 불러오기 🌐상품 목록을 보여주려면 상품 데이터를 먼저 불러와야 해요. 그러기 위해서는 useState()와 useEffect() 훅을 사용해 상품 목록과 로딩 여부를 관리하겠습니다. 아래 코드처럼 작성해보세요!function App() { const [products, setProducts] = React.useState([]); const [loading, setLoading] = React.useState(true); React.useEffect(() =&gt; { setTimeout(() =&gt; { fetch(\"https://dummyjson.com/products\") .then((res) =&gt; res.json()) .then(({ products }) =&gt; { setProducts(products); setLoading(false); }); }, 1000); }, []); return ( &lt;div className=\"grid\"&gt; &lt;header className=\"container\"&gt; &lt;h1&gt;상품 목록&lt;/h1&gt; &lt;/header&gt; &lt;main className=\"container\"&gt; &lt;Products products={products} loading={loading} /&gt; &lt;/main&gt; &lt;/div&gt; );}필터 양식 컴포넌트 만들기 🖌️이제 사용자가 원하는 카테고리나 브랜드를 선택하고 검색어를 입력할 수 있는 양식을 만들 차례에요. 필터 양식은 아래와 같이 만들면 돼요!function FilterForm({ initialValues, onSubmit }) { const [values, setValues] = React.useState(initialValues); React.useEffect(() =&gt; { setValues(initialValues); }, [initialValues]); return ( &lt;form onSubmit={(event) =&gt; { event.preventDefault(); onSubmit(values); }} &gt; // 여기에 select 박스와 체크박스를 넣어요! &lt;button&gt;검색&lt;/button&gt; &lt;/form&gt; );}마치며 🎉이제 우리의 상품 목록 페이지는 사용자가 필터를 사용해 원하는 상품만 쉽게 찾을 수 있는 멋진 페이지가 되었어요! 이렇게 함께 작은 프로젝트를 완성했는데, 어떠셨나요지금까지 함께 해주셔서 감사합니다. 다음에 또 만나요! 🎈" } ]
